<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>COLORIFY</title>
    <!-- Add Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <!-- Add Bootstrap Icons -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/nano.min.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
      .harmony-container {
          position: relative;
          display: inline-block;
      }
      
      .btn-success3 {
          background-color: #28a745;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 8px;
      }
      
      .harmony-menu {
          position: absolute;
          bottom: 100%;
          left: 0;
          background-color: white;
          border: 1px solid #ddd;
          border-radius: 4px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          width: 200px;
          z-index: 1000;
          margin-bottom: 5px;
      }
      
      .menu-item {
          padding: 10px 15px;
          cursor: pointer;
          transition: background-color 0.2s;
      }
      
      .menu-item:hover {
          background-color: #f8f9fa;
      }
      
      .menu-item.active {
          background-color: #e9ecef;
      }
      
      .menu-item:first-child {
          border-top-left-radius: 4px;
          border-top-right-radius: 4px;
      }
      
      .menu-item:last-child {
          border-bottom-left-radius: 4px;
          border-bottom-right-radius: 4px;
      }
      </style>
    <style>
      body {
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      main {
        flex-grow: 1;
        display: flex;
        flex-direction: row;
      }
      header {
        background: #fff !important;
        border-radius: 20px;
        margin-bottom:15px;
        width: 100%;
      }

      .content {
        flex-grow: 1;
        padding: 20px;
        overflow-y: auto;
        transition: all 0.3s;
        background: #fff;
        border-radius: 1%;
      }

      .footer {
        background-color: #343a40;
        color: white;
        text-align: center;
        padding: 10px;
      }

      .sidebar {
        background-color: #f8f9fa;
        overflow-y: auto;
        transition: all 0.3s;
        position: relative;
      }
      
      .sidebar .nav-btn{
        position: absolute;
        right: 7px;
      }
      .collapsed {
        flex: 0 0 46px !important;
      }

      .sidebar ul {
        padding: 0;
        list-style-type: none;
      }

      .sidebar ul li a {
        display: block;
        padding: 10px;
        text-decoration: none;
        color: black;
      }
      .header-logo {
        font-size: 1.5rem;
      }

      .header-profile-pic {
        width: 40px;
        height: 40px;
        border-radius: 50%;
      }
      #leftMostColumn {
        background: #fff;
        margin-right: 10px;
        border-radius: 20px;
      }
      #rightSidebar {
        background: #fff;
        margin-right: 10px;
        margin-left: 10px;
        border-radius: 20px;
      }
      #secondaryColumn {
        background: #fff;
        margin-right: 10px;
        border-radius: 20px;
        height: 100vh;
      }
      .upload-btn{
        color: white;
        border: none;
      }
      .bg-linear-blue{
        background: linear-gradient(to right, #7a85eb , #3C4CD1);
      }
    </style>
    <style>
      body {
        font-family: "Arial", sans-serif;
        background-color: #f8f9fa;
        margin: 0;
        padding:15px;
      }
      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
      }
      .scrollable-container {
        width: calc(100% - 220px);
        height: 84vh;
        overflow: auto;
        border: 1px solid #ddd;
        position: relative;
        margin-right: 220px;
      }
      .zoom-wrapper {
        transform-origin: top left;
        transition: transform 0.3s;
      }
      .canvas-container {
        position: relative;
        overflow: hidden;

        width: {{width}}px;
        height: {{height}}px;
      }
      .layer {
        position: absolute;
        background: transparent;
        pointer-events: none;
      }

      .toolbar h2 {
        font-size: 18px;
        text-align: center;
        margin-bottom: 15px;
      }

      .zoom-controls,
      .layer-toggles {
        //margin-bottom: 20px;
      }
      .zoom-slider {
        width: 100%;
      }
      .layer-toggle-item {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }
      .thumbnail {
        width: 30px;
        height: 30px;
        margin-right: 10px;
        border-radius: 4px;
        border: 1px solid #ddd;
        cursor: pointer;
      }
      .layer-name {
        font-size: 14px;
        flex-grow: 1;
      }
      .color-swatch {
        width: 99px;
        height: 30px;
        //display: inline-block;



      }

      {% comment %} .color-palette {
        display: grid;
        grid-template-columns: repeat(2, 1fr); /* Two equal columns */
        gap: 10px; /* Spacing between items */
      } {% endcomment %}

      {% comment %} .color-swatch {
          width: 100px; /* Fill the grid cell */
          height: 50px; /* Consistent height for swatches */
          border-radius: 5px; /* Optional: rounded corners */
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Optional: subtle shadow */
      } {% endcomment %}
      /* Context Panel Styling */
      .cp_light {
        position: absolute;
        background-color: #ffffff;
        border: 1px solid #ddd;
        box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.15);
        width: 200px;
        z-index: 1500;
        border-radius: 8px;
        display: none; /* Initially hidden */
        padding: 10px;
        overflow-y: auto;
        max-height: 200px;
      }

      .cp_light .option {
        padding: 8px;
        cursor: pointer;
        font-size: 14px;
        color: #333;
      }

      .cp_light .option:hover {
        background-color: #f0f0f0;
      }
      .cp_light {
        position: absolute;
        background-color: #ffffff;
        border: 1px solid #ddd;
        box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.15);
        width: 200px;
        z-index: 1500;
        border-radius: 8px;
        display: none;
        padding: 10px;
        overflow-y: auto;
      }

      .scrollable {
          max-height: 330px;
          overflow-y: auto;
      }

      .enab, .disab {
          padding: 8px;
          font-size: 14px;
          color: #333;
          cursor: pointer;
          display: flex;
          justify-content: space-between;
      }

      .disab {
          color: #aaa;
          cursor: not-allowed;
      }

      .enab:hover {
          background-color: #f0f0f0;
      }

      .context-panel hr {
          margin: 8px 0;
          border-color: #ddd;
      }
      /* Add a small arrow on the left side of the context menu */
      .cp_light::before {
        content: "";
        position: absolute;
        left: -10px;
        top: 10px;
        width: 0;
        height: 0;
        border-top: 10px solid transparent;
        border-bottom: 10px solid transparent;
        border-right: 10px solid #ffffff; /* Match the context menu background color */
      }
      .pickr-container {
        display: flex;
        {% comment %} gap: 10px; /* Space between buttons */ {% endcomment %}
        align-items: center; /* Center vertically if the buttons have different heights */
      }

      .pcr-button {
          width: 40px;
          height:38px;
          border: none;
          cursor: pointer;
      }
      #colorPickerModal .modal-dialog {
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        max-width: 600px; /* Adjust as needed */
        margin: 0;
      }

      #colorPickerModal .modal-content {
          border-radius: 10px 10px 0 0; /* Rounded corners at the top */
          box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
      }
      .modal-backdrop {
        display: none !important;
      }

      #colorPickerModal {
        pointer-events: auto;
      }

      .modal.fade.show {
          background: transparent;
          pointer-events: none; /* Allow clicks through the modal */
      }

      .modal-dialog {
          pointer-events: auto; /* Only the modal dialog should capture clicks */
      }
      #colorPickerModal {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        max-height: 50%;
        pointer-events: auto;
        z-index: 1050; /* Ensure it appears above other content */
      }

      #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }

      .spinner {
          width: 50px;
          height: 50px;
          border: 5px solid rgba(0, 0, 0, 0.1);
          border-top-color: #000;
          border-radius: 50%;
          animation: spin 1s linear infinite;
      }
      .visualizer_toolbar {
        position: fixed;
        bottom: 0;
        background: white;
        left: 0;
        z-index: 101;
        padding: 24px;
        width: 100%;
        box-shadow: rgba(0, 0, 0, 0.075) 0 -1px;
        display: flex;
        justify-content: space-between;
      }
      #visualizer_palette {
        width: 350px;
      }
      .palette-selector {
        height: 46px;
        position: relative;
      }
      .palette-selector.has-btns .palette-selector_colors {
        width: calc(100% - 35px);
      }
      .palette-selector_colors {
        height: 46px;
        width: 100%;
        border-radius: 10px;
        overflow: hidden;
        display: flex;
        position: relative;
      }
      .palette-selector_colors div.is-visible {
        display: block;
      }
      .palette-selector_colors div {
        box-shadow: 1px 0;
        cursor: pointer;
        height: 100%;
        position: relative;
        overflow: hidden;
        float: left;
        display: none;
        flex-grow: 1;
      }
      .palette-selector.has-btns .palette-selector_buttons {
        display: block;
      }
      .palette-selector_buttons {
        position: absolute;
        right: 0;
        top: 0;
        width: 23px;
        text-align: center;
        display: none;
      }
      .palette-selector.has-btns .palette-selector_colors {
        width: calc(100% - 35px);
      }
      @keyframes spin {
          to {
              transform: rotate(360deg);
          }
      }

      .palette-wrapper {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .scroll-container {
          width: 80%; /* Adjust this width as needed */
          overflow-x: auto;
          white-space: nowrap;
          position: relative;
          {% comment %} border-radius:11px; {% endcomment %}
      }

      .color-pickers {
          display: flex;
          gap: 10px;
          padding: 10px;
      }

      .pickr {
          flex: 0 0 auto; /* Prevents shrinking */
      }

      .scroll-btn {
          border:1px solid;
          color: #000;
          border: none;
          padding: 10px;
          cursor: pointer;
          border-radius: 5px;
          font-size: 18px;
      }

      .scroll-btn:hover {
          background-color: #0056b3;
      }

      .pickr .pcr-button{
        height:2em!important;
        margin: 0 .3em 0 .3em !important;

      }


      /* Left Sidebar */
      #leftSidebar {
        position: fixed;
        top: 0;
        left: 0;
        width: 250px;
        height: 100vh;
        background-color: #f5f5f5;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        padding: 20px;
        overflow-y: auto;
        z-index: 1000;
      }

      /* Main Content */
      .scrollable-container {
        margin-left: 250px;
        margin-right: 250px;
        overflow: auto;
        flex: 1;
        position: relative;
      }
      /* Toggle Button */
      .toggle-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: #007bff;
        color: #fff;
        border: none;
        border-radius: 4px;
        padding: 5px;
        cursor: pointer;
      }
      /* Collapsed State */
      .collapsed {
        width: 40px;
      }


      .collapsed .sidebar-content {
        opacity: 0;
        pointer-events: none;
      }

      #leftSidebar {
        left: 0;
      }

      /* Color Palette Styles */
      .color-palette {
        display: flex;
        flex-wrap: wrap;
        margin-top: 10px;
        overflow-x: auto;
      }


      #loader {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 9999;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .color-palette {
        display: grid;
        grid-template-columns: repeat(2, 1fr); /* Two columns */
        //gap: 10px; /* Space between swatches */
      }

      .color-swatch {
          width: 125px; /* Full width within the grid cell */
          height: 25px; /* Fixed height for uniformity */
          //border-radius: 5px; /* Rounded corners */
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Optional shadow */
          cursor: pointer;
          transition: transform 0.2s ease;
      }

      .color-swatch:hover {
          transform: scale(1.05); /* Enlarge slightly on hover */
      }
    </style>
    
  <style>
 .image-adjustments {
    position: relative;
}

.adjustment-panel {
    position: fixed;  /* Changed to fixed positioning */
    left: 60px;      /* Offset from left to not overlap with the button */
    bottom: 20px;    /* Position from bottom */
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    min-width: 250px;
    max-height: 80vh; /* Limit height to 80% of viewport height */
    overflow-y: auto; /* Add scrolling if content is too long */
    z-index: 1000;
}

.layer-adjustments {
    margin-bottom: 20px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background-color: #f9f9f9;
}

.layer-adjustments h4 {
    margin-bottom: 10px;
    font-size: 14px;
    color: #333;
}

.slider-group {
    margin-bottom: 10px;
}

.slider-group label {
    display: block;
    margin-bottom: 5px;
    font-size: 12px;
    color: #666;
}

.slider-group input {
    width: 100%;
}

/* Add some hover effects */
.layer-adjustments:hover {
    border-color: #999;
    transition: border-color 0.2s ease;
}

.color-button-wrapper {
    position: relative;
    display: inline-block;
}

.lock-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    padding: 4px;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s;
}


.color-button-wrapper:hover .lock-overlay {
    opacity: 1;
}

.lock-overlay svg {
    display: block;
}

.mostLeftUl li a {
  position: relative;
  transition: all 0.3s ease;
  padding: 10px;
  display: block;
  text-decoration: none;
  color: #333;
}

.mostLeftUl li a.active {
  background-color: rgba(0, 123, 255, 0.1);
  color: #007bff;
}

.mostLeftUl li a:hover {
  background-color: rgba(0, 123, 255, 0.05);
}

.mostLeftUl li a.active::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  width: 3px;
  background-color: #007bff;
}
.inspiration-placeholder {
  padding: 20px;
  text-align: center;
  border: 2px dashed #dee2e6;
  border-radius: 8px;
  margin-top: 20px;
}

.inspiration-placeholder p {
  margin: 0;
  color: #6c757d;
  font-size: 14px;
}

.sidebar-content {
  display: none;
}

#inspirationContent {
  display: block;
}
.pdf-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);  /* Two columns */
  gap:10px;
  max-width: 1200px;  /* Maximum width for the container */
  margin: 0 auto;     /* Center the grid */
}

.pdf-item {
  height: 170px;
  border: 1px solid #ddd;
  border-radius: 8px;
  overflow: hidden;
  transition: transform 0.2s;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.pdf-preview {
  height: 100%;
  position: relative;
  cursor: pointer;
}

.pdf-preview img {
  width: 100%;
  height: 150px;
  object-fit: cover;
}

.pdf-info {
  padding: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
}

.pdf-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.pdf-likes {
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
}

.download-btn {
  padding: 2px 8px;
  font-size: 12px;
}
.visualizer_buttons_left{
  display:flex!important;
  align-items: center;
  gap: 10px;
}
/* Responsive behavior for smaller screens */
@media (max-width: 768px) {
  .pdf-grid {
      grid-template-columns: 1fr;  /* Single column on mobile */
  }
}


    </style>
    <style>
      .effects-grid {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 15px;
          padding: 15px;
      }
      
      .effect-item {
          border: 1px solid #ddd;
          border-radius: 8px;
          overflow: hidden;
          cursor: pointer;
          transition: transform 0.2s;
      }
      
      .effect-item:hover {
          transform: scale(1.05);
      }
      
      .effect-preview {
          position: relative;
      }
      
      .effect-preview img {
          width: 100%;
          height: 120px;
          object-fit: cover;
      }
      
      .effect-name {
          position: absolute;
          bottom: 0;
          left: 0;
          right: 0;
          background: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 5px;
          text-align: center;
      }
      
      /* Effect-specific styles */
      .effect-item[data-effect="grayscale"] img {
          filter: grayscale(100%);
      }
      
      .effect-item[data-effect="sepia"] img {
          filter: sepia(100%);
      }
      
      .effect-item[data-effect="invert"] img {
          filter: invert(100%);
      }
      
      .effect-item[data-effect="brightness"] img {
          filter: brightness(150%);
      }

      /* Add this to your existing CSS */
.right-sidebar-specific {
  position: relative;
  background: #fff;
  margin-right: 10px;
  margin-left: 10px;
  border-radius: 20px;
  width: 250px;
  min-width: 250px; /* Add this to prevent collapse */
  transition: all 0.3s ease;
  display: flex !important;
  flex-direction: column;
  flex-shrink: 0; /* Add this to prevent shrinking */
}

.right-sidebar-specific .sidebar-content {
  padding: 20px;
  opacity: 1;
  transition: opacity 0.3s ease;
  display: block !important;
}

.right-sidebar-specific.collapsed {
  width: 46px;
  min-width: 46px;
}

.right-sidebar-specific.collapsed .sidebar-content {
  opacity: 0;
  pointer-events: none;
}

/* Layer toggle specific styles */
.right-sidebar-specific .layer-toggles {
  margin-top: 20px;
  opacity: 1;
  transition: opacity 0.3s ease;
  display: block !important;
}

.right-sidebar-specific .layer-toggle-item {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
  padding: 8px;
  background: #f8f9fa;
  border-radius: 8px;
}
      </style>
      
    
  </head>
  <body>
    <div id="loading-screen">
      <div class="spinner"></div>
    </div>
    <!-- Header -->
    <header
      class="text-dark p-2 px-3 d-flex align-items-center justify-content-between ms-auto me-auto"
    >
      <!-- Left: Icon -->
      <div class="header-logo">
        <i class="bi bi-palette"></i>
      </div>

      <!-- Center: Search Bar -->
      {% comment %}
      <div class="flex-grow-1 mx-3">
        <input type="text" class="form-control" placeholder="Search" />
      </div>
      {% endcomment %}

      <!-- Right: Profile Picture with Dropdown -->
      <div class="dropdown">
        <a
          href="#"
          class="d-flex align-items-center text-dark text-decoration-none"
          id="profileDropdown"
          data-bs-toggle="dropdown"
          aria-expanded="false"
        >
          <i class="bi bi-person-bounding-box"></i>
          <span class="ms-2">{{ user.username }}</span>
          <i class="bi bi-caret-down-fill ms-1"></i>
        </a>
        <ul
          class="dropdown-menu dropdown-menu-end text-small shadow"
          aria-labelledby="profileDropdown"
        >
          <li><a class="dropdown-item" href="#">Profile</a></li>
          <li><a class="dropdown-item" href="#">Settings</a></li>
          <li><hr class="dropdown-divider" /></li>
          <li><a class="dropdown-item" href="#">Logout</a></li>
        </ul>
      </div>
    </header>


    <!-- Main Content Area  -->
    <main class="d-flex">
      <!-- Left Sidebar -->
      <div
        id="leftMostColumn"
        class="sidebar d-flex flex-column"
        style="flex: 0 0 150px"
      >
        <button
          class="btn btn-primary btn-sm m-2 d-flex align-items-center"
          onclick="toggleSidebar('leftMostColumn', this)"
        >
          <i class="bi bi-caret-left-fill ms-auto"></i>
        </button>
        <ul class="mostLeftUl">
          <li>
            <a href="#" id="inspirationButton">
              <i class="bi bi-brightness-alt-high me-2 mx-1"></i>
              <span class="textSpan">Inspiration</span>
            </a>
          </li>
          <li>
            <a href="#" id="trendingButton">
              <i class="bi bi-graph-up-arrow mx-1"></i>
              <span class="textSpan">Trending</span>
            </a>
          </li>
          <li>
            <a href="#" id="effectsButton">
              <i class="bi bi-magic mx-1"></i>
              <span class="textSpan">Effects</span>
            </a>
          </li>
          <li>
            <a href="#" id="favoriteButton">
              <i class="bi bi-star mx-1"></i>
              <span class="textSpan">Favourite</span>
            </a>
          </li>
          <li>
            <a href="#" id="baseColorButton">
              <i class="bi bi-palette mx-1"></i>
              <span class="textSpan">Base Color</span>
            </a>
          </li>
          <li>
            <a href="#" id="ssCollectionButton">
              <i class="bi bi-collection mx-1"></i>
              <span class="textSpan">SS Collection</span>
            </a>
          </li>
          <li>
            <a href="#" id="awCollectionButton">
              <i class="bi bi-collection mx-1"></i>
              <span class="textSpan">AW Collection</span>
            </a>
          </li>
        </ul>
      </div>


        <div id="secondaryColumn" class="sidebar d-flex flex-column" style="flex: 0 0 310px">
          <button class="btn-sm m-2 d-flex align-items-center nav-btn" onclick="toggleSidebar('secondaryColumn', this)" style="border: none; background: #fff">
              <i class="bi bi-caret-left-fill ms-auto"></i>
          </button>
          
          <!-- Trending Content -->
          <div class="sidebar-content" id="trendingContent" style="display: none;">
              <h4 class="ms-auto me-auto">Trending Palette</h4>
              <hr />
              <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
          
                  {% for layer in layers %}
              
                  <div class="layer-toggle-item d-flex flex-column gap-2">
                      <div id="colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
                      <div class="d-flex align-items-center justify-content-between w-100">
                        <button id="shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
                          <i class="bi bi-shuffle"></i>
                      </button>
                      <button type="button" id="" class="btn">
                        <i class="bi bi-heart"></i>
                    </button>
                      <button type="button" id="applyButton_{{ forloop.counter }}" class="btn btn-success">
                          <i class="bi bi-magic"></i>
                      </button>
                      </div>
                  </div>
                  {% endfor %}
              </div>
          </div>
      
          <div class="sidebar-content m-4" id="inspirationContent">
            <h4 class="ms-auto me-auto">Inspirations</h4>
            <div class="inspiration-content">
                <div class="pdf-grid">
  
                </div>
            </div>
        </div>
        <div class="sidebar-content" id="effectsContent" style="display: none;">
          <h4 class="ms-auto me-auto">Effects</h4>
          <div class="effects-grid">
              <div class="effect-item" data-effect="grayscale">
                  <div class="effect-preview">
                      <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Grayscale">
                      <div class="effect-name">Grayscale</div>
                  </div>
              </div>
              <div class="effect-item" data-effect="sepia">
                  <div class="effect-preview">
                      <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Sepia">
                      <div class="effect-name">Sepia</div>
                  </div>
              </div>
              <div class="effect-item" data-effect="invert">
                  <div class="effect-preview">
                      <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Invert">
                      <div class="effect-name">Invert</div>
                  </div>
              </div>
              <div class="effect-item" data-effect="brightness">
                  <div class="effect-preview">
                      <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Brightness">
                      <div class="effect-name">Brightness</div>
                  </div>
              </div>
          </div>
      </div>
       <!-- SS Collection Content -->
    <div class="sidebar-content" id="ssCollectionContent" style="display: none;">
      <h4 class="ms-auto me-auto">SS Collection</h4>
      <hr />
      <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
          
        {% for layer in layers %}
    
        <div class="layer-toggle-item d-flex flex-column gap-2">
            <div id="colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
            <div class="d-flex align-items-center justify-content-between w-100">
              <button id="shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
                <i class="bi bi-shuffle"></i>
            </button>
            <button type="button" id="" class="btn">
              <i class="bi bi-heart"></i>
          </button>
            <button type="button" id="applyButton_{{ forloop.counter }}" class="btn btn-success">
                <i class="bi bi-magic"></i>
            </button>
            </div>
        </div>
        {% endfor %}
    </div>
  </div>

  <!-- AW Collection Content -->
  <div class="sidebar-content" id="awCollectionContent" style="display: none;">
      <h4 class="ms-auto me-auto">AW Collection</h4>
      <hr />
      <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
          
        {% for layer in layers %}
    
        <div class="layer-toggle-item d-flex flex-column gap-2">
            <div id="colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
            <div class="d-flex align-items-center justify-content-between w-100">
              <button id="shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
                <i class="bi bi-shuffle"></i>
            </button>
            <button type="button" id="" class="btn">
              <i class="bi bi-heart"></i>
          </button>
            <button type="button" id="applyButton_{{ forloop.counter }}" class="btn btn-success">
                <i class="bi bi-magic"></i>
            </button>
            </div>
        </div>
        {% endfor %}
    </div>
      </div>
  </div>
      </div>


      <!-- Main Content -->
      <div id="mainContent" class="content">
        <div class="d-flex align-items-center justify-content-between">
          <h2 class="fs-4 fw-bold">Workspace</h2>
          <div class="zoom-controls">
            <label for="zoomSlider" class="me-2">Zoom:</label>
            <input
              type="range"
              id="zoomSlider"
              class="zoom-slider"
              min="5"
              max="150"
              value="5"
              step="1"
            />
          </div>
        </div>
        <hr />

        <div class="zoom-wrapper" id="zoomWrapper">
          <div class="canvas-container">
            {% for layer in layers %}
            <div
              class="layer"
              id="layer_{{ forloop.counter }}"
              style="top: {{ layer.layer_position_from_top }}px; left: {{ layer.layer_position_from_left }}px;"
            >
              <canvas 
                id="layer_canvas_{{ forloop.counter }}" 
                data-original-src="{{ layer.path }}"
              ></canvas>
            </div>
            {% endfor %}
          </div>
        </div>
      </div>

      <!-- Right Sidebar -->
      <div
        id="rightSidebar"
        class="sidebar1 d-flex flex-column toolbar scrollable-toolbar"
        style="flex: 0 0 250px"
      >
        <button
          class="btn-sm m-2 d-flex align-items-center"
          onclick="toggleSidebar('rightSidebar', this)"
          style="border: none; background: #fff"
        >
          <i class="bi bi-caret-right-fill ms-auto"></i>
        </button>
        <div class="sidebar-content1 m-4">
          <h4 class="ms-auto me-auto mb-3">Layers</h4>

          <div class="layer-toggles mt-4">
            {% for layer in layers %}
            <div class="layer-toggle-item">
              <img
                id="thumbnail_{{ forloop.counter }}"
                class="thumbnail"
                src=""
                alt="Layer Thumbnail"
              />
              <span class="layer-name">{{ layer.name }}</span>
              <input
                type="checkbox"
                id="toggleLayer{{ forloop.counter }}"
                checked
                onchange="toggleLayer({{ forloop.counter }})"
              />
            </div>
            {% endfor %}
          </div>
        </div>
      </div>
      <div id="contextMenu" class="cp_light">
        <div
          id="layerNameDisplay"
          style="font-weight: bold; margin-bottom: 5px"
        ></div>
        <div class="option" onclick="showLayerInfo()">Edit</div>
      </div>
      <!-- Color Picker Modal -->
      <div
        class="modal fade"
        id="colorPickerModal"
        tabindex="-1"
        role="dialog"
        aria-labelledby="colorPickerModalLabel"
        aria-hidden="true"
        data-backdrop="false"
      >
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title" id="colorPickerModalLabel">
                Select Layer Color
              </h5>
              <div style="text-align: center; margin-bottom: 20px">
                <label for="color-count-slider">Number of Colors: </label>
                <input
                  type="range"
                  id="color-count-slider"
                  min="1"
                  max="10"
                  value="10"
                  oninput="updateColorCountDisplay()"
                />
                <span id="color-count-display">10</span>
              </div>
            </div>
            <div class="modal-body">
              <div
                class="color-picker-container pickr-container"
                id="color-pickers"
              ></div>
              <button
                id="generatePallateColorsBtn"
                class="btn btn-warning mt-2"
                onclick="generatePallateColors()"
              >
                Generate New Colors
              </button>
            </div>
            <div class="modal-footer">
              <button
                type="button"
                class="btn btn-secondary"
                data-dismiss="modal"
                onclick="hideModal()"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      </div>
    </main>

  <!-- Footer -->
<footer class="bg-light text-center py-2 mt-auto visualizer_toolbar d-flex align-items-center justify-content-center gap-4">
     
  <div id="visualizer_buttons_left ">
    <div class="d-flex align-items-center gap-2">
      <div class="upload-wrapper">
        <form id="uploadForm" method="post" enctype="multipart/form-data">
            {% csrf_token %}
            <input type="file" id="fileInput" name="tiff_file" accept=".tif" style="display: none;">
            <button type="button" class="btn btn-outline-dark upload-btn m-0 p-2 px-3 bg-linear-blue" onclick="document.getElementById('fileInput').click();">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cloud-upload" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10a.5.5 0 0 1 0-1h2.688C13.979 10 15 8.988 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-2.941 1.1c-.757.652-1.153 1.438-1.153 2.055v.448l-.445.049C2.064 4.805 1 5.952 1 7.318 1 8.785 2.23 10 3.781 10H6a.5.5 0 0 1 0 1H3.781C1.708 11 0 9.366 0 7.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383"/>
                    <path fill-rule="evenodd" d="M7.646 4.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V14.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708z"/>
                </svg>
                Upload
            </button>
        </form>
    </div>

    
    <div class="image-adjustments">
      <button type="button" class="btn shadow-lg " id="adjustmentToggle">
        <svg width="19" height="19" viewBox="0 0 34 33" fill="none" xmlns="http://www.w3.org/2000/svg">
          <g clip-path="url(#clip0_384_2340)">
            <path
              d="M32.186 15.2545H13.3887C12.7572 12.7733 10.2339 11.2738 7.75261 11.9053C6.10713 12.3241 4.82225 13.609 4.40344 15.2545H1.90915C1.26599 15.2545 0.744629 15.7759 0.744629 16.419C0.744629 17.0622 1.26599 17.5835 1.90915 17.5835H4.40351C5.035 20.0647 7.55836 21.5641 10.0396 20.9326C11.6851 20.5138 12.97 19.2289 13.3888 17.5835H32.186C32.8291 17.5835 33.3505 17.0621 33.3505 16.4189C33.3505 15.7758 32.8291 15.2545 32.186 15.2545ZM8.89611 18.748C7.60987 18.748 6.56715 17.7053 6.56715 16.419C6.56715 15.1328 7.60987 14.09 8.89611 14.09C10.1824 14.09 11.2251 15.1328 11.2251 16.419C11.2251 17.7053 10.1824 18.748 8.89611 18.748Z"
              fill="#3C4CD1" />
            <path
              d="M32.1862 3.60947H28.5274C27.8959 1.12828 25.3726 -0.371188 22.8913 0.260301C21.2458 0.679109 19.9609 1.96399 19.5421 3.60947H1.90939C1.26623 3.60947 0.744873 4.13084 0.744873 4.77399C0.744873 5.41715 1.26623 5.93851 1.90939 5.93851H19.5421C20.1736 8.4197 22.697 9.91917 25.1782 9.28768C26.8237 8.86887 28.1086 7.58399 28.5274 5.93851H32.1862C32.8294 5.93851 33.3507 5.41715 33.3507 4.77399C33.3507 4.13084 32.8294 3.60947 32.1862 3.60947ZM24.0348 7.10296C22.7486 7.10296 21.7058 6.06023 21.7058 4.77399C21.7058 3.48775 22.7486 2.44502 24.0348 2.44502C25.3211 2.44502 26.3638 3.48775 26.3638 4.77399C26.3638 6.06023 25.3211 7.10296 24.0348 7.10296Z"
              fill="#3C4CD1" />
            <path
              d="M32.186 26.8993H26.1981C25.5667 24.4181 23.0433 22.9186 20.562 23.5501C18.9165 23.9689 17.6317 25.2538 17.2129 26.8993H1.90915C1.26599 26.8993 0.744629 27.4206 0.744629 28.0637C0.744629 28.7068 1.26599 29.2282 1.90915 29.2282H17.2129C17.8444 31.7094 20.3678 33.2089 22.849 32.5774C24.4945 32.1586 25.7794 30.8737 26.1982 29.2282H32.186C32.8291 29.2282 33.3505 28.7069 33.3505 28.0637C33.3505 27.4206 32.8291 26.8993 32.186 26.8993ZM21.7055 30.3928C20.4193 30.3928 19.3766 29.35 19.3766 28.0638C19.3766 26.7775 20.4193 25.7348 21.7055 25.7348C22.9918 25.7348 24.0345 26.7775 24.0345 28.0638C24.0345 29.35 22.9918 30.3928 21.7055 30.3928Z"
              fill="#3C4CD1" />
          </g>
          <defs>
            <clipPath id="clip0_384_2340">
              <rect width="32.6059" height="32.6059" fill="white" transform="translate(0.744873 0.115967)" />
            </clipPath>
          </defs>
        </svg>
      </button>
      <div id="adjustmentPanel" class="adjustment-panel" style="display: none;">
          <div class="sliders-container"></div>
      </div>
    </div>
    

   
    </div>
  </div>

  <div id="visualizer_palette" class="palette-wrapper">
      <!-- Left Scroll Button -->
      <button id="scroll-left" class="btn btn-outline-info"><</button>
      <div class="palette-selector has-btns is-sortable has-picker is-lockable is-sortable has-picker is-lockable scroll-container" style="height: 100%;" data-colors="10">
          <div class="color-picker-container mt-1 rounded-2" style="width: fit-content;overflow: hidden;" id="image-color-pickers"></div>
      </div>
      <button id="scroll-right" class="btn btn-outline-info">></button>
  </div>
  <button type="button" class="btn btn-success2 shadow-lg">
    <svg width="20" height="20" viewBox="0 0 33 33" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M19.3118 12.7204C20.2116 11.807 21.2664 11.3242 22.3622 11.3242H26.2204L24.7538 12.7908C24.6119 12.9327 24.4993 13.1012 24.4225 13.2867C24.3457 13.4721 24.3061 13.6708 24.3061 13.8716C24.3061 14.0723 24.3457 14.271 24.4225 14.4565C24.4993 14.6419 24.6119 14.8104 24.7538 14.9523C25.0404 15.239 25.4292 15.4 25.8346 15.4C26.0353 15.4 26.234 15.3605 26.4195 15.2837C26.6049 15.2068 26.7734 15.0943 26.9153 14.9523L30.9911 10.8766C31.133 10.7347 31.2456 10.5662 31.3224 10.3807C31.3992 10.1953 31.4388 9.99654 31.4388 9.79583C31.4388 9.59511 31.3992 9.39635 31.3224 9.21091C31.2456 9.02547 31.133 8.85698 30.9911 8.71505L26.9153 4.63932C26.7734 4.49739 26.6049 4.38481 26.4195 4.308C26.234 4.23118 26.0353 4.19165 25.8346 4.19165C25.6338 4.19165 25.4351 4.23118 25.2497 4.308C25.0642 4.38481 24.8957 4.49739 24.7538 4.63932C24.6119 4.78125 24.4993 4.94974 24.4225 5.13518C24.3457 5.32062 24.3061 5.51937 24.3061 5.72009C24.3061 5.92081 24.3457 6.11956 24.4225 6.305C24.4993 6.49044 24.6119 6.65893 24.7538 6.80086L26.2204 8.26742H22.3622C20.0744 8.26742 17.9771 9.41812 16.468 11.3292C17.1472 12.3407 17.6686 13.4496 18.0142 14.6179C18.3375 13.9172 18.7761 13.2758 19.3118 12.7204Z"
        fill="#3C4CD1" />
      <path
        d="M12.3627 20.1175C11.4628 21.0308 10.408 21.5136 9.31225 21.5136H3.41829C3.01294 21.5136 2.62418 21.6746 2.33755 21.9613C2.05092 22.2479 1.88989 22.6367 1.88989 23.042C1.88989 23.4474 2.05092 23.8361 2.33755 24.1228C2.62418 24.4094 3.01294 24.5704 3.41829 24.5704H9.31225C11.6 24.5704 13.6974 23.4197 15.2065 21.5086C14.5272 20.4972 14.0058 19.3883 13.66 18.22C13.3368 18.9206 12.8983 19.562 12.3627 20.1175Z"
        fill="#3C4CD1" />
      <path
        d="M26.9156 17.8854C26.7737 17.7434 26.6052 17.6309 26.4197 17.554C26.2343 17.4772 26.0355 17.4377 25.8348 17.4377C25.6341 17.4377 25.4354 17.4772 25.2499 17.554C25.0645 17.6309 24.896 17.7434 24.7541 17.8854C24.6121 18.0273 24.4995 18.1958 24.4227 18.3812C24.3459 18.5667 24.3064 18.7654 24.3064 18.9661C24.3064 19.1669 24.3459 19.3656 24.4227 19.551C24.4995 19.7365 24.6121 19.905 24.7541 20.0469L26.2207 21.5135H22.3625C21.2667 21.5135 20.2119 21.0307 19.3121 20.1173C18.3449 19.1357 17.6439 17.7197 17.3383 16.1302C16.4479 11.5006 13.1475 8.26733 9.31225 8.26733H3.41829C3.01294 8.26733 2.62418 8.42836 2.33755 8.71499C2.05092 9.00162 1.88989 9.39038 1.88989 9.79573C1.88989 10.2011 2.05092 10.5898 2.33755 10.8765C2.62418 11.1631 3.01294 11.3241 3.41829 11.3241H9.31225C10.408 11.3241 11.4628 11.8069 12.3627 12.7203C13.3298 13.7019 14.0307 15.1179 14.3364 16.7074C15.2268 21.3369 18.5272 24.5703 22.3625 24.5703H26.2207L24.7541 26.0368C24.4674 26.3235 24.3064 26.7122 24.3064 27.1176C24.3064 27.523 24.4674 27.9117 24.7541 28.1984C25.0407 28.485 25.4295 28.646 25.8348 28.646C26.2402 28.646 26.629 28.485 26.9156 28.1984L30.9913 24.1226C31.1333 23.9807 31.2459 23.8122 31.3227 23.6268C31.3995 23.4413 31.439 23.2426 31.439 23.0419C31.439 22.8412 31.3995 22.6424 31.3227 22.457C31.2459 22.2715 31.1333 22.103 30.9913 21.9611L26.9156 17.8854Z"
        fill="#3C4CD1" />
    </svg>
</button>


<div class="harmony-container">
  <button type="button" class="btn shadow-lg" id="harmonyButton">
    <svg width="20" height="20" viewBox="0 0 34 33" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M7.69539 17.8844C6.91996 17.8844 6.46696 17.0055 6.91804 16.3738L9.19939 13.18L7.93224 8.66352C7.73201 7.94992 8.38976 7.28364 9.11004 7.48571L13.6265 8.75287L16.8203 6.47152C17.4513 6.02094 18.3309 6.47266 18.3309 7.24887V11.3504L22.0167 14.0551C22.6998 14.5563 22.4375 15.6362 21.601 15.7687L20.2474 15.9831L31.9226 26.3235C33.5103 27.7129 33.5925 30.1613 32.1001 31.6535C30.6084 33.1454 28.1582 33.0626 26.7737 31.4803L16.4296 19.8007L16.2153 21.1543C16.0828 21.9906 15.0027 22.2532 14.5016 21.57L11.7969 17.8843H7.69539V17.8844ZM28.2078 30.2179C28.8759 30.9815 30.0421 31.0098 30.7492 30.3026C31.4508 29.6011 31.4362 28.4367 30.6601 27.7575L22.3717 20.4168L20.8633 21.9252L28.2078 30.2179ZM19.5943 20.4923L20.9388 19.1478L17.8028 16.3703L16.9517 16.5051L16.8168 17.3563L19.5943 20.4923ZM13.0509 16.3639L14.6866 18.5929C16.1333 9.45991 13.753 24.4867 15.1732 15.5207C15.238 15.112 15.5586 14.7914 15.9673 14.7267C16.6508 14.6184 18.4071 14.3402 19.0395 14.24L16.8105 12.6043C16.5652 12.4244 16.4204 12.1384 16.4204 11.8342V9.10505L14.3646 10.5736C14.129 10.7418 13.8299 10.7943 13.5512 10.716L10.2311 9.78445L11.1626 13.1046C11.2408 13.3833 11.1884 13.6823 11.0202 13.9179L9.5517 15.9737H12.2808C12.585 15.9738 12.871 16.1186 13.0509 16.3639Z"
        fill="#3C4CD1" />
      <path
        d="M4.5745 3.55524H4.00133V4.12841C4.00133 4.65598 3.57361 5.0837 3.04604 5.0837C2.51847 5.0837 2.09076 4.65598 2.09076 4.12841V3.55524H1.51759C0.990013 3.55524 0.5623 3.12753 0.5623 2.59995C0.5623 2.07238 0.990013 1.64467 1.51759 1.64467H2.09076V1.0715C2.09076 0.543924 2.51847 0.116211 3.04604 0.116211C3.57361 0.116211 4.00133 0.543924 4.00133 1.0715V1.64467H4.5745C5.10207 1.64467 5.52979 2.07238 5.52979 2.59995C5.52979 3.12753 5.10214 3.55524 4.5745 3.55524Z"
        fill="#3C4CD1" />
      <path
        d="M14.8284 4.638H14.2552V5.21117C14.2552 5.73875 13.8275 6.16646 13.2999 6.16646C12.7724 6.16646 12.3447 5.73875 12.3447 5.21117V4.638H11.7715C11.2439 4.638 10.8162 4.21029 10.8162 3.68272C10.8162 3.15514 11.2439 2.72743 11.7715 2.72743H12.3447V2.15426C12.3447 1.62669 12.7724 1.19897 13.2999 1.19897C13.8275 1.19897 14.2552 1.62669 14.2552 2.15426V2.72743H14.8284C15.356 2.72743 15.7837 3.15514 15.7837 3.68272C15.7837 4.21029 15.356 4.638 14.8284 4.638Z"
        fill="#3C4CD1" />
      <path
        d="M5.08409 14.3818C5.08409 14.9094 4.65638 15.3371 4.12881 15.3371C3.60123 15.3371 3.17352 14.9094 3.17352 14.3818V13.8087H2.60035C2.07278 13.8087 1.64506 13.3809 1.64506 12.8534C1.64506 12.3258 2.07278 11.8981 2.60035 11.8981H3.17352V11.3249C3.17352 10.7973 3.60123 10.3696 4.12881 10.3696C4.65638 10.3696 5.08409 10.7973 5.08409 11.3249V11.8981H5.65726C6.18484 11.8981 6.61255 12.3258 6.61255 12.8534C6.61255 13.3809 6.18484 13.8087 5.65726 13.8087H5.08409V14.3818Z"
        fill="#3C4CD1" />
      <path
        d="M1.51759 21.0687H2.09076V20.4956C2.09076 19.968 2.51847 19.5403 3.04604 19.5403C3.57361 19.5403 4.00133 19.968 4.00133 20.4956V21.0687H4.5745C5.10207 21.0687 5.52979 21.4965 5.52979 22.024C5.52979 22.5516 5.10207 22.9793 4.5745 22.9793H4.00133V23.5525C4.00133 24.0801 3.57361 24.5078 3.04604 24.5078C2.51847 24.5078 2.09076 24.0801 2.09076 23.5525V22.9793H1.51759C0.990013 22.9793 0.5623 22.5516 0.5623 22.024C0.5623 21.4965 0.990013 21.0687 1.51759 21.0687Z"
        fill="#3C4CD1" />
      <path
        d="M23.9988 3.55524H23.4256V4.12841C23.4256 4.65598 22.9979 5.0837 22.4704 5.0837C21.9428 5.0837 21.5151 4.65598 21.5151 4.12841V3.55524H20.9419C20.4143 3.55524 19.9866 3.12753 19.9866 2.59995C19.9866 2.07238 20.4143 1.64467 20.9419 1.64467H21.5151V1.0715C21.5151 0.543924 21.9428 0.116211 22.4704 0.116211C22.9979 0.116211 23.4256 0.543924 23.4256 1.0715V1.64467H23.9988C24.5264 1.64467 24.9541 2.07238 24.9541 2.59995C24.9541 3.12753 24.5265 3.55524 23.9988 3.55524Z"
        fill="#3C4CD1" />
      <path
        d="M27.53 7.569L23.9636 9.60694C23.5076 9.86761 22.9232 9.71164 22.6602 9.25151C22.3985 8.79342 22.5576 8.20993 23.0157 7.94812L26.5821 5.91017C27.04 5.64849 27.6236 5.80758 27.8855 6.2656C28.1472 6.72376 27.988 7.30725 27.53 7.569Z"
        fill="#3C4CD1" />
      <path
        d="M29.6047 13.2993C29.5196 13.2993 29.8828 13.3415 25.4091 12.7823C24.8855 12.7169 24.5142 12.2394 24.5797 11.7159C24.6451 11.1923 25.1227 10.8204 25.6461 10.8865L29.722 11.396C30.2455 11.4614 30.6169 11.9389 30.5513 12.4624C30.491 12.9456 30.0795 13.2993 29.6047 13.2993Z"
        fill="#3C4CD1" />
      <path
        d="M8.3946 22.5692C8.65641 22.1111 9.23996 21.9519 9.69799 22.2137C10.156 22.4755 10.3152 23.059 10.0534 23.5171L8.01548 27.0835C7.83913 27.3921 7.51682 27.5651 7.18521 27.5651C6.46435 27.5651 5.989 26.7791 6.35666 26.1356L8.3946 22.5692Z"
        fill="#3C4CD1" />
      <path
        d="M12.1622 24.133C12.6859 24.0673 13.1632 24.439 13.2286 24.9624L13.7381 29.0383C13.8092 29.6067 13.3665 30.1121 12.789 30.1121C12.3143 30.1121 11.9027 29.7585 11.8424 29.2752L11.3329 25.1993C11.2673 24.6759 11.6387 24.1984 12.1622 24.133Z"
        fill="#3C4CD1" />
    </svg>
      Generate
  </button>
  <div class="harmony-menu" id="harmonyMenu" style="display: none;">
      <div class="menu-item" data-harmony="Monochromatic">Monochromatic</div>
      <div class="menu-item" data-harmony="Analogous">Analogous</div>
      <div class="menu-item" data-harmony="Complementary">Complementary</div>
      <div class="menu-item" data-harmony="Split Complementary">Split Complementary</div>
      <div class="menu-item" data-harmony="Triadic">Triadic</div>
      <div class="menu-item" data-harmony="Tetradic">Tetradic</div>
      <div class="menu-item" data-harmony="Square">Square</div>
  </div>
</div>

<div class="harmony-menu" id="harmonyMenu" style="display: none;">
  <div class="menu-item" data-harmony="Monochromatic">Monochromatic</div>
  <div class="menu-item" data-harmony="Analogous">Analogous</div>
  <div class="menu-item" data-harmony="Complementary">Complementary</div>
  <div class="menu-item" data-harmony="Split Complementary">Split Complementary</div>
  <div class="menu-item" data-harmony="Triadic">Triadic</div>
  <div class="menu-item" data-harmony="Tetradic">Tetradic</div>
  <div class="menu-item" data-harmony="Square">Square</div>
</div>

  <div id="visualizer_buttons" class="rounded-2 d-flex bg-linear-blue">
      <button type="button" class="btn btn-success1">
        <svg width="22" height="22" viewBox="0 0 33 32" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M23.2749 28.3968C22.9097 28.803 22.4518 29.115 21.9402 29.3062C21.4286 29.4974 20.8784 29.5623 20.3363 29.4952H6.07123C3.57168 29.4952 2.50497 28.4285 2.50497 25.929V6.90888C2.50497 4.40932 3.57168 3.34261 6.07123 3.34261H14.3925V6.90888C14.2994 7.71194 14.3892 8.52565 14.655 9.28915C14.9207 10.0526 15.3557 10.7462 15.9274 11.3178C16.499 11.8895 17.1925 12.3244 17.956 12.5902C18.7195 12.856 19.5332 12.9457 20.3363 12.8527H23.9026V16.4189C23.9026 16.7342 24.0278 17.0366 24.2507 17.2595C24.4737 17.4824 24.7761 17.6077 25.0913 17.6077C25.4066 17.6077 25.709 17.4824 25.9319 17.2595C26.1548 17.0366 26.2801 16.7342 26.2801 16.4189V11.6639C26.2802 11.5078 26.2495 11.3532 26.1896 11.2091C26.1298 11.0649 26.042 10.934 25.9314 10.8239L16.4213 1.3138C16.3112 1.20317 16.1803 1.11541 16.0361 1.05557C15.892 0.995725 15.7374 0.96498 15.5813 0.965102H6.07123C5.26818 0.872024 4.45446 0.961736 3.69097 1.22753C2.92748 1.49332 2.23397 1.92831 1.66231 2.49996C1.09066 3.07161 0.655674 3.76512 0.389882 4.52862C0.12409 5.29211 0.0343773 6.10582 0.127455 6.90888V25.929C0.0343773 26.732 0.12409 27.5457 0.389882 28.3092C0.655674 29.0727 1.09066 29.7662 1.66231 30.3379C2.23397 30.9095 2.92748 31.3445 3.69097 31.6103C4.45446 31.8761 5.26818 31.9658 6.07123 31.8728H20.3363C21.2537 31.9506 22.1762 31.8025 23.0231 31.4414C23.87 31.0802 24.6155 30.5171 25.1944 29.8012C25.3806 29.5466 25.4581 29.2285 25.4098 28.9169C25.3615 28.6052 25.1913 28.3255 24.9368 28.1393C24.6823 27.953 24.3642 27.8756 24.0525 27.9239C23.7408 27.9722 23.4611 28.1423 23.2749 28.3968ZM16.77 6.90888V5.02431L22.2209 10.4751H20.3363C17.8367 10.4751 16.77 9.40844 16.77 6.90888ZM32.2714 23.599L29.1014 26.769C28.8761 26.979 28.578 27.0933 28.27 27.0879C27.9621 27.0825 27.6682 26.9577 27.4504 26.7399C27.2326 26.5221 27.1079 26.2283 27.1024 25.9203C27.097 25.6123 27.2113 25.3143 27.4213 25.0889L28.5609 23.9477H17.1663C16.851 23.9477 16.5486 23.8225 16.3257 23.5995C16.1028 23.3766 15.9775 23.0742 15.9775 22.759C15.9775 22.4437 16.1028 22.1413 16.3257 21.9184C16.5486 21.6954 16.851 21.5702 17.1663 21.5702H28.5609L27.4213 20.429C27.2113 20.2036 27.097 19.9056 27.1024 19.5976C27.1079 19.2897 27.2326 18.9958 27.4504 18.778C27.6682 18.5602 27.9621 18.4355 28.27 18.43C28.578 18.4246 28.8761 18.5389 29.1014 18.7489L32.2714 21.9189C32.3809 22.0302 32.4681 22.1615 32.5282 22.3056C32.6179 22.5227 32.6415 22.7615 32.5958 22.992C32.5501 23.2224 32.4372 23.4326 32.2714 23.599Z"
            fill="white" />
        </svg>
      </button>

  </div>
</footer>

<style>
.upload-wrapper {
  position: relative;
  display: inline-block;
  line-height: 0;
}
#fileInput {
  display: none;
}
#uploadForm {
  margin: 0 !important;
  padding: 0 !important;
  display: inline-block;
  line-height: 0;
}
button {
  margin: 0 !important;
  line-height: 1;
}
</style>

<script>
document.getElementById('fileInput').onchange = function() {
  if (this.files.length > 0) {
      document.getElementById('uploadForm').submit();
  }
};
</script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>

      </script>
    <script>


      document.addEventListener('DOMContentLoaded', function() {
        const trendingButton = document.getElementById('trendingButton');
        const secondaryColumn = document.getElementById('secondaryColumn');
    
        // Initially hide the secondary column
        secondaryColumn.style.display = 'none';
    
        trendingButton.addEventListener('click', function(e) {
            e.preventDefault();
            
            // Toggle the secondary column
            if (secondaryColumn.style.display === 'none') {
                secondaryColumn.style.display = 'flex';
                // If the sidebar is collapsed, uncollapse it
                if (secondaryColumn.classList.contains('collapsed')) {
                    const toggleButton = secondaryColumn.querySelector('button');
                    toggleSidebar('secondaryColumn', toggleButton);
                }
            } else {
                secondaryColumn.style.display = 'none';
            }
        });
    });


      // Function to toggle sidebar collapsed state and change the icon
      function toggleSidebar(id, button) {
        const sidebar = document.getElementById(id);
        const icon = button.querySelector("i");
        const mostLeftUl = sidebar.querySelectorAll(
          ".mostLeftUl li a .textSpan"
        );
        mostLeftUl.forEach((span) => {
          if (span.style.display === "none") {
            span.style.display = "inline"; // Show the span
          } else {
            span.style.display = "none"; // Hide the span
          }
        });

        sidebar.classList.toggle("collapsed");

        // Update the icon based on the collapse state
        if (sidebar.classList.contains("collapsed")) {

          icon.classList.remove("bi-caret-left-fill", "bi-caret-right-fill");
          icon.classList.add("bi-caret-right-fill");
          //mostLeftUl.style.display = "none";
        } else {

          icon.classList.remove("bi-caret-left-fill", "bi-caret-right-fill");
          icon.classList.add("bi-caret-left-fill");
          //mostLeftUl.style.display = "inline";
        }
      }
      function hideModal(){
        $('#colorPickerModal').modal('hide');
      }

      document.addEventListener('DOMContentLoaded', function() {
        const secondaryColumn = document.getElementById('secondaryColumn');
        const navButtons = document.querySelectorAll('.mostLeftUl li a');
        const inspirationButton = document.getElementById('inspirationButton');
        const trendingContent = document.getElementById('trendingContent');
        const inspirationContent = document.getElementById('inspirationContent');
        const ssCollectionContent = document.getElementById('ssCollectionContent');
        const awCollectionContent = document.getElementById('awCollectionContent');
        
        // Function to show content
        function showContent(contentId) {
            // Hide all content sections
            const contents = document.querySelectorAll('.sidebar-content');
            contents.forEach(content => {
                content.style.display = 'none';
            });
            
            // Show the selected content
            document.getElementById(contentId).style.display = 'block';
        }
    
        // Function to handle active state
        function setActiveButton(activeButton) {
            navButtons.forEach(button => {
                button.classList.remove('active');
            });
            activeButton.classList.add('active');
        }
    
        // Effect application logic
        const effectItems = document.querySelectorAll('.effect-item');
        effectItems.forEach(item => {
            item.addEventListener('click', function() {
                const effect = this.dataset.effect;
                applyEffectToLayers(effect);
            });
        });
    
        // Add click handlers for all navigation buttons
        navButtons.forEach(button => {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                setActiveButton(this);
                
                // Handle different sections
                switch(this.id) {
                    case 'trendingButton':
                        secondaryColumn.style.display = 'flex';
                        showContent('trendingContent');
                        break;
                        
                    case 'inspirationButton':
                        secondaryColumn.style.display = 'flex';
                        showContent('inspirationContent');
                        break;
                        
                    case 'effectsButton':
                        secondaryColumn.style.display = 'flex';
                        showContent('effectsContent');
                        break;
                        
                    case 'ssCollectionButton':
                        secondaryColumn.style.display = 'flex';
                        showContent('ssCollectionContent');
                        break;
                        
                    case 'awCollectionButton':
                        secondaryColumn.style.display = 'flex';
                        showContent('awCollectionContent');
                        break;
                        
                    case 'favoriteButton':
                    case 'baseColorButton':
                    default:
                        // Hide secondary column for all other buttons
                        secondaryColumn.style.display = 'none';
                        break;
                }
                
                // If the sidebar is collapsed, uncollapse it
                if (secondaryColumn.classList.contains('collapsed')) {
                    const toggleButton = secondaryColumn.querySelector('button');
                    toggleSidebar('secondaryColumn', toggleButton);
                }
            });
        });
    
        // Set initial state
        window.onload = function() {
            // Show Inspiration content by default
            secondaryColumn.style.display = 'flex';
            showContent('inspirationContent');
            setActiveButton(inspirationButton);
        };
    });
      const layerStates = {
        editedImages: {},
        originalImages: {}, // Add this to store original states
        saveEditedState: function(layerIndex) {
            const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
            if (canvas) {
                this.editedImages[layerIndex] = canvas.toDataURL();
            }
        },
        saveOriginalState: function(layerIndex) {
            const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
            if (canvas) {
                this.originalImages[layerIndex] = canvas.toDataURL();
            }
        },
        getEditedState: function(layerIndex) {
            return this.editedImages[layerIndex];
        },
        getOriginalState: function(layerIndex) {
            return this.originalImages[layerIndex];
        },
        hasEditedState: function(layerIndex) {
            return !!this.editedImages[layerIndex];
        },
        hasOriginalState: function(layerIndex) {
            return !!this.originalImages[layerIndex];
        }
    };

{% comment %} effect js  {% endcomment %}

document.addEventListener('DOMContentLoaded', function() {
  // Add effects button handler
  const effectsButton = document.getElementById('effectsButton');
  if (effectsButton) {
      effectsButton.addEventListener('click', function(e) {
          e.preventDefault();
          secondaryColumn.style.display = 'flex';
          showContent('effectsContent');
          if (secondaryColumn.classList.contains('collapsed')) {
              const toggleButton = secondaryColumn.querySelector('button');
              toggleSidebar('secondaryColumn', toggleButton);
          }
      });
  }

  // Effect application logic
  const effectItems = document.querySelectorAll('.effect-item');
  effectItems.forEach(item => {
      item.addEventListener('click', function() {
          const effect = this.dataset.effect;
          applyEffectToLayers(effect);
      });
  });
});
function applyEffectToLayers(effect) {
  const totalLayers = document.querySelectorAll('[id^="layer_canvas_"]').length;
  
  for (let layer = 1; layer <= totalLayers; layer++) {
      // Check if layer is locked
      const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
      if (colorButton && colorButton.dataset.locked === 'true') {
          console.log(`Layer ${layer} is locked, skipping effect`);
          continue;
      }

      const canvas = document.getElementById(`layer_canvas_${layer}`);
      if (!canvas) continue;

      const ctx = canvas.getContext('2d');
      if (!ctx) continue;

      // Save the current state if not already saved
      if (!layerStates.hasOriginalState(layer)) {
          layerStates.saveOriginalState(layer);
      }

      // Apply the effect
      switch(effect) {
          case 'grayscale':
              applyGrayscale(ctx, canvas.width, canvas.height);
              break;
          case 'sepia':
              applySepia(ctx, canvas.width, canvas.height);
              break;
          case 'invert':
              applyInvert(ctx, canvas.width, canvas.height);
              break;
          case 'brightness':
              applyBrightness(ctx, canvas.width, canvas.height, 1.5);
              break;
      }

      // Save the edited state
      layerStates.saveEditedState(layer);
  }
}

function applyGrayscale(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg;     // Red
      data[i + 1] = avg; // Green
      data[i + 2] = avg; // Blue
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applySepia(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
      data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
      data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyInvert(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      data[i] = 255 - data[i];         // Red
      data[i + 1] = 255 - data[i + 1]; // Green
      data[i + 2] = 255 - data[i + 2]; // Blue
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyBrightness(ctx, width, height, factor) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.min(255, data[i] * factor);
      data[i + 1] = Math.min(255, data[i + 1] * factor);
      data[i + 2] = Math.min(255, data[i + 2] * factor);
  }
  
  ctx.putImageData(imageData, 0, 0);
}
{% comment %} effect js end  {% endcomment %}


{% comment %} for pdf {% endcomment %}
// Function to download PDF
function loadInspirationContent() {
  const inspirationContent = document.getElementById('inspirationContent');

  // Show loading state
  inspirationContent.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';

  fetch('inspiration-pdfs/') // Update this URL to match your URL configuration
      .then(response => response.json())
      .then(data => {
          let htmlContent = `
              <h4 class="ms-auto me-auto">Inspirations</h4>
              <div class="inspiration-content">
                  <div class="pdf-grid">
          `;

          data.pdfs.forEach(pdf => {
              htmlContent += `
                  <div class="pdf-item">
                      <div class="pdf-preview" data-pdf-id="${pdf.id}">
                          <img src="${pdf.preview_image}" alt="${pdf.title}">
                          <div class="pdf-info">
                              <span class="pdf-name">${pdf.title}</span>
                              <div class="pdf-actions">
                                  <span class="pdf-likes">
                                      <i class="bi ${pdf.liked ? 'bi-heart-fill' : 'bi-heart'}"></i> 
                                      <span class="likes-count">${pdf.likes_count}</span>
                                  </span>
                                  <button class="btn btn-sm btn-primary download-btn">
                                      <i class="bi bi-download"></i>
                                  </button>
                              </div>
                          </div>
                      </div>
                  </div>
              `;
          });

          htmlContent += `
                  </div>
              </div>
          `;

          inspirationContent.innerHTML = htmlContent;
          initializePDFEvents(); // Call this after adding the content
      })
      .catch(error => {
          console.error('Error:', error);
          inspirationContent.innerHTML = '<div class="alert alert-danger">Error loading PDFs</div>';
      });
}

function toggleLike(pdfId, element) {
  fetch('inspiration-pdfs/', {
      method: 'POST',
      headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-CSRFToken': getCookie('csrftoken'),
      },
      body: `pdf_id=${pdfId}`
  })
  .then(response => response.json())
  .then(data => {
      // Update the like button and count based on the response
      element.className = data.liked ? 'bi bi-heart-fill' : 'bi-heart';
      element.closest('.pdf-likes').querySelector('.likes-count').textContent = data.likes_count;
  })
  .catch(error => console.error('Error:', error));
}

function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
          }
      }
  }
  return cookieValue;
}

function downloadPDF(pdfUrl, title) {
  fetch(pdfUrl)
      .then(response => response.blob())
      .then(blob => {
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = title;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
      })
      .catch(error => {
          console.error('Error downloading PDF:', error);
          alert('Error downloading the PDF');
      });
}

function initializePDFEvents() {
  document.querySelectorAll('.pdf-likes i').forEach(element => {
      element.addEventListener('click', function(e) {
          e.stopPropagation();
          const pdfId = this.closest('.pdf-preview').dataset.pdfId;
          toggleLike(pdfId, this);
      });
  });

  document.querySelectorAll('.download-btn').forEach(button => {
      button.addEventListener('click', function(e) {
          e.stopPropagation();
          const pdfPreview = this.closest('.pdf-preview');
          const pdfUrl = pdfPreview.dataset.pdfUrl; // Make sure to add this data attribute in your HTML
          const title = pdfPreview.querySelector('.pdf-name').textContent;
          downloadPDF(pdfUrl, title);
      });
  });
}

// Call this function when the page loads
loadInspirationContent();

// Call this function when inspiration button is clicked
document.getElementById('inspirationButton').addEventListener('click', function(e) {
  e.preventDefault();
  loadInspirationContent();
});
{% comment %} end pdf  {% endcomment %}


{% comment %} for generating random color pallete  {% endcomment %}

      function displayColorPalette(layerIndex, colors, maxVisibleColors = 6) {
        const paletteContainer = document.getElementById(`colorPalette_${layerIndex}`);
        paletteContainer.innerHTML = '';
    
        // Keep track of whether the palette is expanded
        let isExpanded = false;
    
        // Store the initial colors if not already stored
        window.originalPaletteColors = window.originalPaletteColors || {};
        if (!window.originalPaletteColors[layerIndex]) {
            window.originalPaletteColors[layerIndex] = [...colors];
        }
        
        // Store the current colors for this specific palette
        window.trendingPaletteColors = window.trendingPaletteColors || {};
        window.trendingPaletteColors[layerIndex] = colors;
    
        // Track the toggle state for this palette
        window.paletteToggleState = window.paletteToggleState || {};
        window.paletteToggleState[layerIndex] = window.paletteToggleState[layerIndex] || false;
    
        // Function to render the color swatches based on the current state
        function renderPalette() {
            paletteContainer.innerHTML = '';
    
            // Determine which colors to show based on the state
            const colorsToDisplay = isExpanded ? colors : colors.slice(0, maxVisibleColors);
            const remainingColorsCount = colors.length - maxVisibleColors;
    
            // Display the selected colors
            colorsToDisplay.forEach((color) => {
                const swatch = document.createElement('div');
                swatch.classList.add('color-swatch');
                swatch.style.backgroundColor = `rgb(${color.join(',')})`;
                swatch.title = `rgb(${color.join(',')})`;
                paletteContainer.appendChild(swatch);
            });
    
            // Add the "More" or "Less" label if needed
            if (remainingColorsCount > 0) {
                const toggleLabel = document.createElement('div');
                toggleLabel.classList.add('toggle-colors-label');
                toggleLabel.innerHTML = isExpanded
                    ? '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-minus" viewBox="0 0 16 16"><path d="M5.5 8a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1H6a.5.5 0 0 1-.5-.5"/><path d="M4 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 1h8a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1"/></svg>'
                    : `<span class="mx-1" style="font-weight:bold;color:red;">${remainingColorsCount}</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-plus" viewBox="0 0 16 16"><path d="M8.5 6a.5.5 0 0 0-1 0v1.5H6a.5.5 0 0 0 0 1h1.5V10a.5.5 0 0 0 1 0V8.5H10a.5.5 0 0 0 0-1H8.5z"/><path d="M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2zm10-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1"/></svg>`;
    
                toggleLabel.addEventListener('click', () => {
                    isExpanded = !isExpanded;
                    renderPalette();
                });
    
                paletteContainer.appendChild(toggleLabel);
            }
        }
    
        // Initial render
        renderPalette();
    }



    
      function loadZoomValue(){
        //document.getElementById('zoomWrapper').style.transform = `scale(${0.072})`;
        document.getElementById('zoomWrapper').style.transform = `scale(${0.3})`;
      }
      document.addEventListener('DOMContentLoaded', loadZoomValue);
      document.getElementById('zoomSlider').addEventListener('input', function() {
        const zoomLevel = this.value / 100;
        //const zoomLevel = 0.3;

        document.getElementById('zoomWrapper').style.transform = `scale(${zoomLevel})`;
      });

      function toggleLayer(layerIndex) {
        const layerDiv = document.getElementById(`layer_${layerIndex}`);
        const checkbox = document.getElementById(`toggleLayer${layerIndex}`);
        layerDiv.style.display = checkbox.checked ? 'block' : 'none';
      }

      // Analyze the image data to calculate layer-specific parameters
      function analyzeImageLayer(ctx) {
        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const data = imageData.data;

        let totalLightness = 0;
        let totalHue = 0;
        let pixelCount = 0;

        const hues = [];

        for (let i = 0; i < data.length; i += 4) {
            // Ignore fully transparent pixels
            if (data[i + 3] === 0) continue;

            const rgb = [data[i], data[i + 1], data[i + 2]];
            const hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);

            totalLightness += hsl[2];
            totalHue += hsl[0];
            hues.push(hsl[0]);
            pixelCount++;
        }

        // Handle cases where no valid pixels were processed
        if (pixelCount === 0) {
            return {
                avgLightness: 0,
                avgHue: 0,
                hueRange: 0,
                lightnessTolerance: 0,
                hueTolerance: 0,
            };
        }

        const avgLightness = totalLightness / pixelCount;
        const avgHue = totalHue / pixelCount;

        let hueRange = calculateHueRange(hues);

        const lightnessTolerance = Math.min(0.5, avgLightness * 0.5); // Adjusted scaling
        const hueTolerance = Math.min(40, hueRange * 0.5);            // Adjusted scaling

        return {
            avgLightness,
            avgHue,
            hueRange,
            lightnessTolerance,
            hueTolerance,
        };
      }

      function analyzeImageLayerforsingle(ctx) {
         const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
         const data = imageData.data;

         let totalLightness = 0;
         let totalHue = 0;
         let pixelCount = 0;

         const hues = [];

         for (let i = 0; i < data.length; i += 4) {
             // Ignore fully transparent pixels
             if (data[i + 3] === 0) continue;

             const rgb = [data[i], data[i + 1], data[i + 2]];
             const hsl = rgbToHslforsingle(rgb[0], rgb[1], rgb[2]);

             totalLightness += hsl[2];
             totalHue += hsl[0];
             hues.push(hsl[0]);
             pixelCount++;
         }

         // Handle cases where no valid pixels were processed
         if (pixelCount === 0) {
             //console.warn("No valid pixels found in layer.");
             return {
                 avgLightness: 0,
                 avgHue: 0,
                 hueRange: 0,
                 lightnessTolerance: 0,
                 hueTolerance: 0,
             };
         }

         const avgLightness = totalLightness / pixelCount;
         const avgHue = totalHue / pixelCount;

         // Calculate hue range only if there are hues available
         //const hueRange = hues.length > 0 ? Math.max(...hues) - Math.min(...hues) : 0;
         let hueRange = calculateHueRangeforsingle(hues);



         const lightnessTolerance = Math.min(0.7, avgLightness / 2); // Scaled by avgLightness
         const hueTolerance = Math.min(47, hueRange / 2);            // Scaled by hue range


         return {
             avgLightness,
             avgHue,
             hueRange,
             lightnessTolerance,
             hueTolerance,
         };
       }
      function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                    break;
                case g:
                    h = ((b - r) / d + 2) / 6;
                    break;
                case b:
                    h = ((r - g) / d + 4) / 6;
                    break;
            }
        }
        return [h, s, l];
      }

      function hslToRgb(h, s, l) {
        let r, g, b;

        if (s === 0) {
            r = g = b = l; // achromatic
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1; if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return [r, g, b];
      }

// Function to convert RGB to HSL
function rgbToHslforsingle(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // Achromatic
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }

        h /= 6;
    }

    return [h, s, l];
}

function hslToRgbforsingle(h, s, l) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l; // Achromatic
    } else {
        const hue2rgb = function (p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r * 255, g * 255, b * 255];
}

   function calculateHueRange(hues) {
        if (hues.length === 0) return 0;

        // Convert hues to degrees (0 to 360)
        const huesInDegrees = hues.map(h => h * 360);

        // Sort hues
        huesInDegrees.sort((a, b) => a - b);

        // Calculate differences between adjacent hues
        let maxDiff = 0;
        for (let i = 0; i < huesInDegrees.length - 1; i++) {
            const diff = huesInDegrees[i + 1] - huesInDegrees[i];
            if (diff > maxDiff) maxDiff = diff;
        }

        // Include wrap-around difference
        const wrapAroundDiff = 360 - huesInDegrees[huesInDegrees.length - 1] + huesInDegrees[0];
        if (wrapAroundDiff > maxDiff) maxDiff = wrapAroundDiff;

        return maxDiff;
      }

      function calculateHueRangeforsingle(hues) {
         if (hues.length === 0) return 0;

         let maxHue = -Infinity;
         let minHue = Infinity;

         for (let hue of hues) {
             if (hue > maxHue) maxHue = hue;
             if (hue < minHue) minHue = hue;
         }

         return maxHue - minHue;
       }
      function getDistinctColors(imageData, threshold = 50, maxColors = 5) {
        const colorCounts = {};
        const data = imageData.data;

        // Count the frequency of each color
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];

            // Skip fully transparent pixels
            if (a === 0) continue;
            // Skip black and white colors
            //if ((r === 0 && g === 0 && b === 0) || (r === 255 && g === 255 && b === 255)) continue;
            if ((r === 0 && g === 0 && b === 0)) continue;
            const colorKey = `${r},${g},${b}`;
            if (!colorCounts[colorKey]) {
                colorCounts[colorKey] = 0;
            }
            colorCounts[colorKey]++;
        }

        // Sort colors by frequency
        const colors = Object.entries(colorCounts)
            .map(([key, count]) => ({
                rgb: key.split(',').map(Number),
                count,
            }))
            .sort((a, b) => b.count - a.count);

        const distinctColors = [];

        // Function to calculate Euclidean distance in RGB space
        function colorDistance(c1, c2) {
            return Math.sqrt(
                Math.pow(c1[0] - c2[0], 2) +
                Math.pow(c1[1] - c2[1], 2) +
                Math.pow(c1[2] - c2[2], 2)
            );
        }

        // Add colors if they are distinct enough
        colors.forEach(({ rgb }) => {
            if (distinctColors.length >= maxColors) return;

            const isDistinct = distinctColors.every((d) => colorDistance(d, rgb) > threshold);
            if (isDistinct) {
                distinctColors.push(rgb);
            }
        });

        return distinctColors;
      }


      function generateUniqueRGBColorArray(count) {
    const colors = [];

    while (colors.length < count) {
        // Generate random R, G, B values between 0 and 255
        const r = Math.floor(Math.random() * 256);
        const g = Math.floor(Math.random() * 256);
        const b = Math.floor(Math.random() * 256);

        // Check if the generated color is green-dominated or already exists
        const isGreenish = (g > r && g > b); // Exclude if green is the dominant color
        const isDuplicate = colors.some(color => color[0] === r && color[1] === g && color[2] === b);

        // If the color is unique and not green-dominated, add it to the array
        if (!isGreenish && !isDuplicate) {
            colors.push([r, g, b]);
        }
    }

    return colors;
}

      function showLayerInfo() {
        contextMenu.style.display = 'none';
        $('#colorPickerModal').modal('show');
        const layerIndex = contextMenu.dataset.layerIndex; // Assuming contextMenu is defined

        updateLayersWithNewColorCount(layerIndex);
      }

      async function processLayerAsync(ctx, targetColor, newColor, minAreaThreshold = 1, maxSkipCount = 5) {
    return new Promise(async (resolve) => {
        const colorProcessor = new ColorProcessor();
        
        // Get the layer index from the canvas ID
        const canvasId = ctx.canvas.id;
        const layerIndex = parseInt(canvasId.replace('layer_canvas_', ''));
        
        // Convert canvas to image data URL
        const imageDataUrl = ctx.canvas.toDataURL();
        console.log('Processing layer with colors:', {
            targetColor: targetColor,
            newColor: newColor
        });

        try {
            // Get color mapping analysis
            const colorMapping = await colorProcessor.getColorMapping(imageDataUrl);
            
            // Apply color mapping
            const processedImageUrl = await colorProcessor.applyColorMapping(
                imageDataUrl,
                colorMapping,
                newColor,    // Target color to map to
                targetColor  // Original/dominant color to replace
            );
            
            // Load the processed image back to canvas
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.drawImage(img, 0, 0);
                
                // Update the footer button color
                updateFooterColorButton(layerIndex, newColor);
                
                resolve();
            };
            img.src = processedImageUrl;
            
        } catch (error) {
            console.error('Error processing layer:', error);
            resolve();
        }
    });
}

      function updateLayersWithNewColorCount(layerIndex){
        console.info("layerIndex"+layerIndex);
        const layerIndexCount = layerIndex - 1;
        const sliderValue = document.getElementById('color-count-slider').value;
        const totalLayers = {{ layers|length }};
        const layers = {{ layers|safe }};

        let distinctColorTolarance = 0;
        let applicationColorTolarance = 0;
        let lightnessApplicationColorTolarance = 0;
        if(totalLayers>5){
          distinctColorTolarance = 180;

        }else{
          distinctColorTolarance = 200;
        }
        //distinctColorTolarance = 210;

        let layer = layers[layerIndexCount];
        let img = new Image();
        img.src = layer.path;
        let canvas = document.getElementById('layer_canvas_'+layerIndex);
        let ctx = canvas.getContext('2d', { willReadFrequently: true });
        let latestImageData = null;
        img.onload = function() {
          const colorPickerContainer = document.getElementById('color-pickers');
          colorPickerContainer.innerHTML = '';
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          let targetColors = [];
          latestImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const distinctColors  = getDistinctColors(imageData,180, sliderValue);

          distinctColors.forEach((color, index) => {
          //if (color[0] !== 0 || color[1] !== 0 || color[2] !== 0) { // Ignore black
              const button = document.createElement('button');
              button.className = 'color-picker';
              button.style.backgroundColor = `rgb(${color.join(',')})`;
              document.getElementById('color-pickers').appendChild(button);

              const pickr = Pickr.create({
                el: button,
                theme: 'nano',
                default: `rgb(${color.join(',')})`,
                components: {
                    preview: true,
                    opacity: true,
                    hue:true,


                    interaction: {
                        rgba: true,
                        input: true,
                        hsla: true,
                        save: true,
                    }
                }
              });
              let isProcessing = false;
              pickr.on('save', (newColor) => {
    if (isProcessing) return;
    const rgbaColor = newColor.toRGBA().map(v => Math.round(v));

    const currentTargetColor = distinctColors[index];

    isProcessing = true;
    processLayerAsync(ctx, currentTargetColor, rgbaColor).then(() => {
        // Update the footer button color after processing
        updateFooterColorButton(layerIndex, rgbaColor);
    });
    setTimeout(() => {
        isProcessing = false;
    }, 100);

    latestImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    ctx.putImageData(latestImageData, 0, 0);

    button.style.backgroundColor = `rgba(${rgbaColor.join(',')})`;
    distinctColors[index] = rgbaColor.slice(0, 3);

    pickr.hide();
});

          //}
          });
        };

      }
      async function processLayer(ctx, targetColor, newColor) {

        console.info('Processing Layer with target color:', targetColor, 'and new color:', newColor);

        let {
            avgLightness,
            avgHue,
            hueRange,
            lightnessTolerance,
            hueTolerance,
        } = analyzeImageLayer(ctx);

        console.info('Layer Analysis Results:', {
            avgLightness,
            avgHue,
            hueRange,
            lightnessTolerance,
            hueTolerance,
        });
        hueTolerance = 360;
        lightnessTolerance = 1.0;
        changeHueWithHueAndLightnessTolerance(ctx, targetColor, newColor, hueTolerance, lightnessTolerance);

        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const dominantColor = getDominantColor(imageData);

        // Process non-dominant colors
        processNonDominantColors(ctx, dominantColor);


        console.info('Finished processing layer');
                

                console.info('Finished processing layer');
              }

              function isColorInArray(color, array) {
  return array.some(existingColor =>
    existingColor[0] === color[0] &&
    existingColor[1] === color[1] &&
    existingColor[2] === color[2]
  );
}
      function changeHueWithHueAndLightnessTolerance(ctx, targetColor, newColor, hueTolerance, lightnessTolerance) {
        console.info('Processing Layer with target color:', targetColor, 'and new color:', newColor);
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;
        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        const data = imageData.data;

        // Convert target and new colors to HSL
        const targetHsl = rgbToHsl(...targetColor);
        const newHsl = rgbToHsl(...newColor);

        // Normalize hue tolerance to fraction (since hue is between 0 and 1 in HSL)
        //const hueToleranceFraction = hueTolerance / 360;
        const hueToleranceFraction = Math.max(0.05, hueTolerance / 360); // Minimum 5% tolerance
        //const lightnessTolerance = Math.max(0.1, lightnessTolerance);   // Minimum 10% tolerance

        for (let i = 0; i < data.length; i += 4) {
            const currentColor = [data[i], data[i + 1], data[i + 2]];
            const currentHsl = rgbToHsl(...currentColor);

            // Calculate hue and lightness differences
            let hueDiff = Math.abs(currentHsl[0] - targetHsl[0]);
            if (hueDiff > 0.5) hueDiff = 1 - hueDiff; // Wrap-around for hue differences
            const lightnessDiff = Math.abs(currentHsl[2] - targetHsl[2]);
            //console.log(`Pixel ${i / 4}: Matches Tolerance (HueDiff: ${hueDiff}, LightnessDiff: ${lightnessDiff})`);
            // Check if the pixel's hue and lightness are within tolerance range
            if (hueDiff <= hueToleranceFraction && lightnessDiff <= lightnessTolerance) {
                //const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);
                const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);

                // Scale RGB values to 0-255 and assign to data array
                data[i] = Math.round(blendedRgb[0] * 255);
                data[i + 1] = Math.round(blendedRgb[1] * 255);
                data[i + 2] = Math.round(blendedRgb[2] * 255);
            }
        }

        ctx.putImageData(imageData, 0, 0);
      }


      
      function changeHueWithHueAndLightnessTolerance(ctx, targetColor, newColor, hueTolerance, lightnessTolerance) {
  console.info('Processing Layer with target color:', targetColor, 'and new color:', newColor);
  const canvasWidth = ctx.canvas.width;
  const canvasHeight = ctx.canvas.height;
  const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
  const data = imageData.data;

  // Convert target and new colors to HSL
  const targetHsl = rgbToHsl(...targetColor);
  const newHsl = rgbToHsl(...newColor);

  // Normalize hue tolerance to fraction (since hue is between 0 and 1 in HSL)
  const hueToleranceFraction = hueTolerance / 360; // Strict hue tolerance
  const lightnessTolerance1 = Math.max(0.05, lightnessTolerance); // Minimum 5% lightness tolerance
  const minSaturation = 0.1; // Minimum saturation threshold

  for (let i = 0; i < data.length; i += 4) {
    const currentColor = [data[i], data[i + 1], data[i + 2]];
    const currentHsl = rgbToHsl(...currentColor);

    // Skip desaturated colors
    if (currentHsl[1] < minSaturation) continue;

    // Calculate hue and lightness differences
    let hueDiff = Math.abs(currentHsl[0] - targetHsl[0]);
    if (hueDiff > 0.5) hueDiff = 1 - hueDiff; // Wrap-around for hue differences
    const lightnessDiff = Math.abs(currentHsl[2] - targetHsl[2]);

    // Check if the pixel's hue and lightness are within tolerance range
    if (hueDiff <= hueToleranceFraction && lightnessDiff <= lightnessTolerance1) {
      const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);

      // Scale RGB values to 0-255 and assign to data array
      data[i] = Math.round(blendedRgb[0] * 255);
      data[i + 1] = Math.round(blendedRgb[1] * 255);
      data[i + 2] = Math.round(blendedRgb[2] * 255);
    }
  }

  ctx.putImageData(imageData, 0, 0);
}


function updateColorCountDisplay() {
         const sliderValue = document.getElementById('color-count-slider').value;
         document.getElementById('color-count-display').innerText = sliderValue;

       }

        {% comment %} // Helper function to calculate color distance
       function colorDistance(color1, color2) {
         return Math.sqrt(
             Math.pow(color1[0] - color2[0], 2) +
             Math.pow(color1[1] - color2[1], 2) +
             Math.pow(color1[2] - color2[2], 2)
         );
       } {% endcomment %}

 
       // Function to convert RGB to HSL
       function rgbToHsl(r, g, b) {
         r /= 255;
         g /= 255;
         b /= 255;

         const max = Math.max(r, g, b);
         const min = Math.min(r, g, b);
         let h, s, l = (max + min) / 2;

         if (max === min) {
             h = s = 0; // Achromatic
         } else {
             const d = max - min;
             s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

             switch (max) {
                 case r:
                     h = (g - b) / d + (g < b ? 6 : 0);
                     break;
                 case g:
                     h = (b - r) / d + 2;
                     break;
                 case b:
                     h = (r - g) / d + 4;
                     break;
             }

             h /= 6;
         }

         return [h, s, l];
       }
       async function generatePallateColors() {
        updateColorCountDisplay();
        const layerIndex = contextMenu.dataset.layerIndex;
        const layerIndexCount = layerIndex - 1;
        const sliderValue = document.getElementById('color-count-slider').value;
    
        const layers = {{ layers|safe }};
        let layer = layers[layerIndexCount];
        let img = new Image();
        img.src = layer.path;
        let canvas = document.getElementById('layer_canvas_'+layerIndex);
        let ctx = canvas.getContext('2d', { willReadFrequently: true });
        let latestImageData = null;
    
        img.onload = async function() {
            const colorPickerContainer = document.getElementById('color-pickers');
            colorPickerContainer.innerHTML = '';
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
    
            // Create ImageColorAnalyzer instance
            const analyzer = new ImageColorAnalyzer();
            const colorAnalysis = await analyzer.analyzeImageColors(img);
    
            // Get all colors including dominant and other colors
            let distinctColors = [colorAnalysis.dominantColor];
            if (colorAnalysis.otherColors) {
                colorAnalysis.otherColors.forEach(color => {
                    distinctColors.push(color.rgb);
                });
            }
    
            // Store original colors
            window.originalColors = [...distinctColors];
    
            // Limit colors based on slider value
            distinctColors = distinctColors.slice(0, parseInt(sliderValue));
    
            // Create color pickers for each distinct color
            distinctColors.forEach((color, index) => {
                const button = document.createElement('button');
                button.className = 'color-picker';
                button.style.backgroundColor = `rgb(${color.join(',')})`;
                
                // Get color name using analyzer
                const colorName = analyzer.getColorGroup(...color);
                button.title = colorName;
                
                document.getElementById('color-pickers').appendChild(button);
    
                const pickr = Pickr.create({
                    el: button,
                    theme: 'nano',
                    default: `rgb(${color.join(',')})`,
                    components: {
                        preview: true,
                        opacity: true,
                        hue: true,
                        interaction: {
                            rgba: true,
                            input: true,
                            hsla: true,
                            save: true,
                        }
                    }
                });
    
                let isProcessing = false;
                pickr.on('save', async (newColor) => {
                    if (isProcessing) return;
                    const rgbaColor = newColor.toRGBA().map(v => Math.round(v));
                    const currentTargetColor = distinctColors[index];
    
                    isProcessing = true;
                    await processLayerAsync(ctx, currentTargetColor, rgbaColor);
                    
                    button.style.backgroundColor = `rgba(${rgbaColor.join(',')})`;
                    distinctColors[index] = rgbaColor.slice(0, 3);
    
                    isProcessing = false;
                    pickr.hide();
                });
            });
    
            // Create a shuffle button for this color set
            const shuffleButton = document.createElement('button');
            shuffleButton.className = 'btn btn-sm btn-secondary mt-2';
            shuffleButton.innerHTML = '<i class="bi bi-shuffle"></i> Shuffle Colors';
            shuffleButton.onclick = async () => {
                const newColorAnalysis = await analyzer.analyzeImageColors(img);
                const newColors = [newColorAnalysis.dominantColor];
                
                if (newColorAnalysis.otherColors) {
                    newColorAnalysis.otherColors.forEach(color => {
                        if (newColors.length < distinctColors.length) {
                            newColors.push(color.rgb);
                        }
                    });
                }
    
                // Update existing color pickers with new colors
                const colorPickers = document.querySelectorAll('#color-pickers .color-picker');
                colorPickers.forEach((picker, index) => {
                    if (newColors[index]) {
                        picker.style.backgroundColor = `rgb(${newColors[index].join(',')})`;
                        distinctColors[index] = newColors[index];
                    }
                });
            };
            
            document.getElementById('color-pickers').appendChild(shuffleButton);
        };
    }

async function processPallet(layerCtx, totalLayers, layerCanvas, currentLayerIndex, oldColorArray, trendingColors) {
  const loadingScreen = document.getElementById('loading-screen');
  loadingScreen.style.display = 'block';
  const analyzer = new ImageColorAnalyzer();
  const colorProcessor = new ColorProcessor();

  try {
      for (let layer = 1; layer <= totalLayers; layer++) {
          // Check if this layer's color is locked
          const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
          if (colorButton && colorButton.dataset.locked === 'true') {
              console.log(`Layer ${layer} is locked, skipping processing`);
              continue;
          }

          console.info(`Processing Layer ${layer}/${totalLayers}`);

          const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
          if (!layerCanvas) continue;

          const layerCtx = layerCanvas.getContext('2d');
          if (!layerCtx) continue;

          // Load and draw original image first
          const originalImg = new Image();
          const originalSrc = layerCanvas.getAttribute('data-original-src');
          if (!originalSrc) {
              console.error(`Original source not found for layer ${layer}`);
              continue;
          }
          originalImg.src = originalSrc;
          
          await new Promise((resolve, reject) => {
              originalImg.onload = () => {
                  layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                  layerCtx.drawImage(originalImg, 0, 0);
                  resolve();
              };
              originalImg.onerror = () => {
                  console.error(`Failed to load original image for layer ${layer}`);
                  reject(new Error(`Failed to load original image for layer ${layer}`));
              };
          });

          const tempImage = new Image();
          tempImage.src = layerCanvas.toDataURL('image/png');
          const base64Data = layerCanvas.toDataURL('image/png');
          
          await new Promise((resolve) => {
              tempImage.onload = resolve;
          });

          const colorAnalysis = await analyzer.analyzeImageColors(tempImage);

          if (!colorAnalysis) {
              console.error('Color analysis failed');
              continue;
          }

          // Process dominant color
          console.log(`Dominant Color Name: ${colorAnalysis.dominantColorName}`);
          const colorIndex = (layer - 1) % trendingColors.length;
          const targetColor = trendingColors[colorIndex];

          // Use ColorProcessor for dominant color
          const colorMapping = await colorProcessor.getColorMapping(base64Data);
          const modifiedImage = await colorProcessor.applyColorMapping(
              base64Data, 
              colorMapping, 
              targetColor,
              colorAnalysis.dominantColor
          );
          updateFooterColorButton(layer, targetColor);

          // Apply the modified image to the canvas and wait for it to load
          await new Promise((resolve) => {
              const img = new Image();
              img.onload = () => {
                  layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                  layerCtx.drawImage(img, 0, 0);
                  resolve();
              };
              img.src = modifiedImage;
          });

          // Get updated canvas data after dominant color modification
          const updatedImage = new Image();
          updatedImage.src = layerCanvas.toDataURL('image/png');
          await new Promise((resolve) => {
              updatedImage.onload = resolve;
          });

          // Analyze updated colors after dominant color change
          const updatedColorAnalysis = await analyzer.analyzeImageColors(updatedImage);

          // Process other colors using updated color analysis
          if (updatedColorAnalysis.otherColors && updatedColorAnalysis.otherColors.length > 0) {
              console.log('Processing Other Colors:', updatedColorAnalysis.otherColors.length);
              const isBlack = (rgb) => {
                  return rgb[0] <= 30 && rgb[1] <= 30 && rgb[2] <= 30;
              };
              
              const colorsToProcess = updatedColorAnalysis.otherColors.filter(color => {
                  return !isBlack(color.rgb) && 
                         !isColorInArray(color.rgb, trendingColors) && 
                         color.percentage > 1.0;
              });
              
              if (colorsToProcess.length > 0) {
                  console.log('Processing secondary colors:');
                  for (const color of colorsToProcess) {
                      console.log(`Processing Color: ${color.colorName}, RGB: ${color.rgb}, Percentage: ${color.percentage.toFixed(2)}%`);
                      const targetColorIndex = (trendingColors.indexOf(targetColor) + 1) % trendingColors.length;
                      await processLayerAsync(layerCtx, color.rgb, trendingColors[targetColorIndex]);
                  }
              }
          } else {
              console.log('No other colors found for this layer.');
          }
      }
  } catch (error) {
      console.error("Error while processing pallet:", error);
  } finally {
      loadingScreen.style.display = 'none';
  }
}
function isColorInArray(color, colorArray) {
    return colorArray.some(arrayColor => {
        const tolerance = 32;
        return Math.abs(arrayColor[0] - color[0]) <= tolerance &&
               Math.abs(arrayColor[1] - color[1]) <= tolerance &&
               Math.abs(arrayColor[2] - color[2]) <= tolerance;
    });
}
function getRandomColor() {
  const r = Math.floor(Math.random() * 256);
  const g = Math.floor(Math.random() * 256);
  const b = Math.floor(Math.random() * 256);
  return [r, g, b];
}
function processNonDominantColors(ctx, dominantColor) {
    if (!dominantColor || !dominantColor.nonDominantColors || dominantColor.nonDominantColors.length === 0) {
        console.log('No non-dominant colors found');
        return;
    }

    console.log('Non-dominant colors:', dominantColor.nonDominantColors);

    const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    const data = imageData.data;

    // Analyze the current layer for dynamic thresholds
    const analysis = analyzeImageLayer(ctx);
    const { hueTolerance, lightnessTolerance } = analysis;

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3];

        if (a === 0) continue; // Skip fully transparent pixels

        const currentColor = [r, g, b];

        // Check if the current color is a non-dominant color
        if (!isColorInArray(currentColor, dominantColor.nonDominantColors)) continue;

        // Convert current color to HSL
        const currentHsl = rgbToHsl(r, g, b);

        // Calculate hue and lightness differences from the dominant color
        const dominantHsl = rgbToHsl(...dominantColor.referenceColor);
        const hueDiff = Math.abs(currentHsl[0] - dominantHsl[0]);
        const lightnessDiff = Math.abs(currentHsl[2] - dominantHsl[2]);

        // Check if the pixel's hue and lightness are within tolerance range
        if (
            hueDiff <= hueTolerance / 360 && // Normalize hue tolerance
            lightnessDiff <= lightnessTolerance
        ) {
            const randomColor = getRandomColor();
            console.log('Replacing non-dominant color', currentColor, 'with', randomColor);
            data[i] = randomColor[0];
            data[i + 1] = randomColor[1];
            data[i + 2] = randomColor[2];
        }
    }

    ctx.putImageData(imageData, 0, 0);
}

function updateFooterColorButton(layerIndex, newColor) {
    const colorButton = document.querySelector(`.color-picker[data-layer-index="${layerIndex-1}"]`);
    if (colorButton) {
        colorButton.style.backgroundColor = Array.isArray(newColor) ? 
            `rgb(${newColor.join(',')})` : newColor;
    }
}
class ImageColorAnalyzer {
    constructor() {
        this.logger = console;
        this.cv = null;
        this.isReady = false;
        this.initializationPromise = null;
    }

    async initialize() {
        // If already initialized, return
        if (this.isReady) return;

        // If initialization is in progress, return the existing promise
        if (this.initializationPromise) {
            return this.initializationPromise;
        }

        this.initializationPromise = new Promise((resolve, reject) => {
            // Check if OpenCV is already loaded
            if (typeof cv !== 'undefined') {
                this.cv = cv;
                this.isReady = true;
                resolve();
                return;
            }

            // Check if the script is already being loaded
            const existingScript = document.querySelector('script[src*="opencv.js"]');
            if (existingScript) {
                existingScript.addEventListener('load', () => {
                    this.cv = cv;
                    this.isReady = true;
                    resolve();
                });
                existingScript.addEventListener('error', () => {
                    reject(new Error('Failed to load OpenCV.js'));
                });
                return;
            }

            // Load OpenCV if not already loading
            const script = document.createElement('script');
            script.src = 'https://docs.opencv.org/4.8.0/opencv.js';
            script.async = true;
            script.type = 'text/javascript';

            // Only set Module if it's not already defined
            if (typeof window.Module === 'undefined') {
                window.Module = {
                    onRuntimeInitialized: () => {
                        this.cv = cv;
                        this.isReady = true;
                        resolve();
                    }
                };
            }

            script.onerror = () => {
                reject(new Error('Failed to load OpenCV.js'));
            };

            document.body.appendChild(script);
        });

        return this.initializationPromise;
    }

    rgbToLab(r, g, b) {
        // Convert RGB to XYZ
        r = r / 255;
        g = g / 255;
        b = b / 255;

        // RGB to XYZ conversion
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

        r *= 100;
        g *= 100;
        b *= 100;

        const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        const z = r * 0.0193 + g * 0.1192 + b * 0.9505;

        // XYZ to Lab conversion
        const xn = 95.047;
        const yn = 100.000;
        const zn = 108.883;

        const fx = x / xn > 0.008856 ? Math.pow(x / xn, 1/3) : (7.787 * x / xn) + 16/116;
        const fy = y / yn > 0.008856 ? Math.pow(y / yn, 1/3) : (7.787 * y / yn) + 16/116;
        const fz = z / zn > 0.008856 ? Math.pow(z / zn, 1/3) : (7.787 * z / zn) + 16/116;

        const L = (116 * fy) - 16;
        const a = 500 * (fx - fy);
        const b_val = 200 * (fy - fz);

        return [L, a, b_val];
    }

    calculateColorDifference(lab1, lab2) {
        // Delta E 2000 calculation (simplified version)
        const deltaL = lab2[0] - lab1[0];
        const deltaA = lab2[1] - lab1[1];
        const deltaB = lab2[2] - lab1[2];

        return Math.sqrt(
            Math.pow(deltaL, 2) +
            Math.pow(deltaA, 2) +
            Math.pow(deltaB, 2)
        );
    }

    async analyzeImageColors(imageElement) {
        if (!this.isReady) {
            await this.initialize();
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = imageElement.width;
        canvas.height = imageElement.height;
        ctx.drawImage(imageElement, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;

        // Store colors with their frequency and LAB values
        const colorMap = new Map();
        const totalPixels = pixels.length / 4;

        // Sample pixels (analyze every 4th pixel for performance)
        for (let i = 0; i < pixels.length; i += 16) {
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            const a = pixels[i + 3];

            // Skip transparent pixels
            if (a < 127) continue;

            const key = `${r},${g},${b}`;
            const lab = this.rgbToLab(r, g, b);

            if (colorMap.has(key)) {
                colorMap.get(key).count++;
            } else {
                colorMap.set(key, {
                    rgb: [r, g, b],
                    lab: lab,
                    count: 1
                });
            }
        }

        // Convert map to array for processing
        let colors = Array.from(colorMap.values());

        // Merge similar colors
        const mergedColors = [];
        const threshold = 5; // Color difference threshold

        while (colors.length > 0) {
            const baseColor = colors[0];
            let totalCount = baseColor.count;
            const similarColors = [baseColor];

            // Find and merge similar colors
            for (let i = 1; i < colors.length; i++) {
                const diff = this.calculateColorDifference(baseColor.lab, colors[i].lab);
                if (diff < threshold) {
                    totalCount += colors[i].count;
                    similarColors.push(colors[i]);
                }
            }

            // Calculate weighted average color
            const avgColor = similarColors.reduce((acc, curr) => {
                const weight = curr.count / totalCount;
                return {
                    rgb: [
                        acc.rgb[0] + curr.rgb[0] * weight,
                        acc.rgb[1] + curr.rgb[1] * weight,
                        acc.rgb[2] + curr.rgb[2] * weight
                    ]
                };
            }, { rgb: [0, 0, 0] });

            mergedColors.push({
                rgb: avgColor.rgb.map(Math.round),
                percentage: (totalCount / (totalPixels / 4)) * 100
            });

            // Remove processed colors
            colors = colors.filter(c => !similarColors.includes(c));
        }

        // Sort by percentage and group by basic color categories
        const colorGroups = {};
        
        mergedColors.sort((a, b) => b.percentage - a.percentage)
            .forEach(color => {
                const colorGroup = this.getColorGroup(...color.rgb);
                
                if (!colorGroups[colorGroup]) {
                    colorGroups[colorGroup] = {
                        totalPercentage: 0,
                        shades: []
                    };
                }

                colorGroups[colorGroup].shades.push({
                    rgb: color.rgb,
                    percentage: color.percentage
                });
                colorGroups[colorGroup].totalPercentage += color.percentage;
            });

        // Sort and format results
        const sortedGroups = Object.entries(colorGroups)
            .map(([name, data]) => ({
                name,
                totalPercentage: data.totalPercentage,
                dominantShade: data.shades.sort((a, b) => b.percentage - a.percentage)[0]
            }))
            .sort((a, b) => b.totalPercentage - a.totalPercentage);

        const dominantGroup = sortedGroups[0];
        const otherColors = sortedGroups.slice(1, 5).map(group => ({
            colorName: group.name,
            rgb: group.dominantShade.rgb,
            percentage: group.totalPercentage
        }));

        // Console log results
     
        // console.log('Dominant Color:', {
        //     name: dominantGroup.name,
        //     rgb: dominantGroup.dominantShade.rgb,
        //     percentage: dominantGroup.totalPercentage.toFixed(2) + '%'
        // });


        // otherColors.forEach((color, index) => {
        //     console.log(`Color ${index + 1}:`, {
        //         name: color.colorName,
        //         rgb: color.rgb,
        //         percentage: color.percentage.toFixed(2) + '%'
        //     });
        // });

        const [h, s, l] = this.rgbToHsl(...dominantGroup.dominantShade.rgb);

        return {
            dominantColor: dominantGroup.dominantShade.rgb,
            dominantColorName: dominantGroup.name,
            dominantPercentage: dominantGroup.totalPercentage,
            otherColors: otherColors,
            hue: h * 360,
            saturation: s * 100,
            lightness: l * 100
        };
    }

    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return [h, s, l];
    }

    getColorGroup(r, g, b) {
    const [h, s, l] = this.rgbToHsl(r, g, b);
    const hue = h * 360;

    // Define color ranges by hue
    if (l < 0.1) return 'black';
    if (l > 0.9 && s < 0.1) return 'white';
    if (s < 0.15 && l > 0.1 && l < 0.9) return 'gray';

    // Hue-based color grouping
    if ((hue >= 345 || hue <= 10) && s > 0.15) return 'red';
    if (hue > 10 && hue <= 45) return 'orange';
    if (hue > 45 && hue <= 65) return 'yellow';
    if (hue > 65 && hue <= 170) return 'green';
    if (hue > 170 && hue <= 190) return 'cyan';
    if (hue > 190 && hue <= 260) return 'blue';
    if (hue > 260 && hue <= 320) return 'magenta';
    if (hue > 320 && hue <= 345) return 'purple';

    return 'other';
}
}

class ColorProcessor {
  constructor() {
        this.EPSILON = 0.0001;
        this.COLOR_SIMILARITY_THRESHOLD = 30;
        this.COLOR_QUANTIZATION_STEP = 10; // Added for color quantization
        this.cv = null; // Will store OpenCV instance
        
        // Bind methods
        this.applyColorMapping = this.applyColorMapping.bind(this);
   
       
        this.rgbToHsv = this.rgbToHsv.bind(this);
        this.hsvToRgb = this.hsvToRgb.bind(this);
        this.quantizeColor = this.quantizeColor.bind(this)
    }

    rgbToLab(rgb) {
      // First, convert RGB to XYZ using D65 illuminant
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;

      // Convert to sRGB space
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

      // Convert to XYZ space
      const x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
      const y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
      const z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

      // Convert XYZ to Lab
      const xn = 95.047;
      const yn = 100.000;
      const zn = 108.883;

      const fx = x / xn > 0.008856 ? Math.pow(x / xn, 1/3) : (903.3 * x / xn + 16) / 116;
      const fy = y / yn > 0.008856 ? Math.pow(y / yn, 1/3) : (903.3 * y / yn + 16) / 116;
      const fz = z / zn > 0.008856 ? Math.pow(z / zn, 1/3) : (903.3 * z / zn + 16) / 116;

      const L = Math.max(0, 116 * fy - 16);
      const a = 500 * (fx - fy);
      const c = 200 * (fy - fz);

      return [L, a, c];
  }

  rgbToHsv(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const diff = max - min;
        
        let h = 0;
        if (max === min) {
            h = 0;
        } else if (max === r) {
            h = (60 * ((g - b) / diff) + 360) % 360;
        } else if (max === g) {
            h = (60 * ((b - r) / diff) + 120) % 360;
        } else {
            h = (60 * ((r - g) / diff) + 240) % 360;
        }
        
        const s = max === 0 ? 0 : diff / max;
        const v = max;
        
        return [h, s, v];
    }







   
    isColorSimilar(color1, color2) {
    const hsv1 = this.rgbToHsv(color1);
    const hsv2 = this.rgbToHsv(color2);
    
    // Calculate hue difference
    let hueDiff = Math.abs(hsv1[0] - hsv2[0]);
    if (hueDiff > 180) hueDiff = 360 - hueDiff;
    
    // Make the similarity check more strict
    const saturationThreshold = (hsv1[1] < 0.1 || hsv2[1] < 0.1) ? 0.1 : 0.2;
    
    return (
        (hueDiff < 20 || (hsv1[1] < 0.1 && hsv2[1] < 0.1)) && // Stricter hue check
        Math.abs(hsv1[1] - hsv2[1]) < saturationThreshold && 
        Math.abs(hsv1[2] - hsv2[2]) < 0.3
    );
}
quantizeColor(rgb) {
    return rgb.map(v => Math.round(v / this.COLOR_QUANTIZATION_STEP) * this.COLOR_QUANTIZATION_STEP);
}
    calculateColorDistance(lab1, lab2) {
        return Math.sqrt(
            Math.pow(lab1[0] - lab2[0], 2) +
            Math.pow(lab1[1] - lab2[1], 2) +
            Math.pow(lab1[2] - lab2[2], 2)
        );
    }

    findSimilarColors(currentLab, shades, threshold = 25) {
        return shades.filter(shade => 
            this.calculateColorDistance(currentLab, shade.lab) < threshold
        );
    }

    async getColorMapping(imageData) {
    // Import tinycolor2 dynamically if not already loaded
    if (typeof tinycolor === 'undefined') {
        await new Promise((resolve) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.4.2/tinycolor.min.js';
            script.onload = resolve;
            document.head.appendChild(script);
        });
    }

    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imgData.data;
            
            const colorMap = new Map();
            const validPixels = [];
            
            for (let i = 0; i < pixels.length; i += 4) {
                if (pixels[i + 3] > 128) {
                    const rgb = [pixels[i], pixels[i + 1], pixels[i + 2]];
                    const color = tinycolor({ r: rgb[0], g: rgb[1], b: rgb[2] });
                    
                    // Skip colors with very low saturation or extreme brightness
                    const hsl = color.toHsl();
                    if (hsl.s < 0.15 || hsl.l < 0.1 || hsl.l > 0.9) {
                        continue;
                    }

                    const quantizedRgb = this.quantizeColor(rgb);
                    const key = quantizedRgb.join(',');
                    colorMap.set(key, (colorMap.get(key) || 0) + 1);
                    validPixels.push(rgb);
                }
            }

            if (colorMap.size === 0) {
                resolve({
                    baseColor: [0, 0, 0],
                    shades: []
                });
                return;
            }

            // Get unique colors and their Lab values
            const shades = Array.from(colorMap.keys()).map(key => {
                const rgb = key.split(',').map(Number);
                const color = tinycolor({ r: rgb[0], g: rgb[1], b: rgb[2] });
                return {
                    original: rgb,
                    lab: this.rgbToLab(rgb),
                    frequency: colorMap.get(key),
                    hsv: color.toHsv(),
                    brightness: color.getBrightness(),
                };
            });

            // Enhanced sorting considering both frequency and color properties
            shades.sort((a, b) => {
                const freqWeight = 0.7;
                const satWeight = 0.3;
                
                const aScore = (a.frequency * freqWeight) + (a.hsv.s * satWeight * 100);
                const bScore = (b.frequency * freqWeight) + (b.hsv.s * satWeight * 100);
                
                return bScore - aScore;
            });

            const baseColor = shades[0].original;

            resolve({
                baseColor,
                shades
            });
        };
        img.src = imageData;
    });
}
async applyColorMapping(imageData, colorMapping, targetColor, dominantColor) {
  return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
          const canvasElement = document.createElement('canvas');
          const ctx = canvasElement.getContext('2d');
          canvasElement.width = img.width;
          canvasElement.height = img.height;

          ctx.drawImage(img, 0, 0);
          const imageDataObj = ctx.getImageData(0, 0, img.width, img.height);
          const data = imageDataObj.data;

          function rgbToHsl(r, g, b) {
              r /= 255; g /= 255; b /= 255;
              const max = Math.max(r, g, b);
              const min = Math.min(r, g, b);
              let h, s, l = (max + min) / 2;

              if (max === min) {
                  h = s = 0;
              } else {
                  const d = max - min;
                  s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                  switch (max) {
                      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                      case g: h = (b - r) / d + 2; break;
                      case b: h = (r - g) / d + 4; break;
                  }
                  h /= 6;
              }
              return [h * 360, s * 100, l * 100];
          }

          function hslToRgb(h, s, l) {
              h /= 360; s /= 100; l /= 100;
              let r, g, b;

              if (s === 0) {
                  r = g = b = l;
              } else {
                  const hue2rgb = (p, q, t) => {
                      if (t < 0) t += 1;
                      if (t > 1) t -= 1;
                      if (t < 1/6) return p + (q - p) * 6 * t;
                      if (t < 1/2) return q;
                      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                      return p;
                  };

                  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                  const p = 2 * l - q;
                  r = hue2rgb(p, q, h + 1/3);
                  g = hue2rgb(p, q, h);
                  b = hue2rgb(p, q, h - 1/3);
              }
              return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
          }

          const dominantHSL = rgbToHsl(...dominantColor);
          const targetHSL = rgbToHsl(...targetColor);
          const tolerance = 35;

          for (let i = 0; i < data.length; i += 4) {
              if (data[i + 3] < 128) continue; // Skip transparent pixels

              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];

 
              const pixelHSL = rgbToHsl(r, g, b);
              let hueDifference = Math.abs(pixelHSL[0] - dominantHSL[0]);
              if (hueDifference > 180) hueDifference = 360 - hueDifference;
              
              const isGrayOrWhite = pixelHSL[1] < 15 && pixelHSL[2] > 100;
              const dominantIsGrayOrWhite = dominantHSL[1] < 15 && dominantHSL[2] > 100;

              if (hueDifference < tolerance || 
                  (isGrayOrWhite && dominantIsGrayOrWhite && 
                   Math.abs(pixelHSL[2] - dominantHSL[2]) < 30 && 
                   Math.abs(pixelHSL[1] - dominantHSL[1]) < 15)) {
                  
                  const brightnessRatio = pixelHSL[2] / dominantHSL[2];
                  let adjustedLightness = targetHSL[2] * brightnessRatio;

                  if (pixelHSL[2] > dominantHSL[2]) {
                      adjustedLightness = Math.max(adjustedLightness, targetHSL[2] * 0.9);
                  }
                  
                  adjustedLightness = Math.max(10, Math.min(100, adjustedLightness));

                  const saturation = Math.abs(pixelHSL[1] - dominantHSL[1]) < 5 ? 
                      targetHSL[1] : 
                      pixelHSL[1] * (targetHSL[1] / dominantHSL[1]);

                  const newRGB = hslToRgb(
                      targetHSL[0],
                      Math.max(0, Math.min(100, saturation)),
                      adjustedLightness
                  );

                  data[i] = newRGB[0];
                  data[i + 1] = newRGB[1];
                  data[i + 2] = newRGB[2];
              }
          }

          ctx.putImageData(imageDataObj, 0, 0);
          const dataUrl = canvasElement.toDataURL('image/png');
          resolve(dataUrl);
      };
      img.src = imageData;
  });
}
// Helper functions
calculateDeltaE(lab1, lab2) {
    const deltaL = lab1[0] - lab2[0];
    const deltaA = lab1[1] - lab2[1];
    const deltaB = lab1[2] - lab2[2];
    return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
}

hsvToRgb(hsv) {
    let h = hsv[0];
    let s = hsv[1];
    let v = hsv[2];
    
    let r, g, b;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);

    switch (i % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
    }

    return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255)
    ];
}

}
async function processHarmony(layerCtx, totalLayers, layerCanvas, currentLayerIndex, harmonyType) {
  const loadingScreen = document.getElementById('loading-screen');
  loadingScreen.style.display = 'block';
  const analyzer = new ImageColorAnalyzer();
  const colorProcessor = new ColorProcessor();

  try {
      // First, analyze the dominant color of the first unlocked layer
      let dominantColor = null;
      let firstUnlockedLayer = null;

      for (let layer = 1; layer <= totalLayers; layer++) {
          const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
          if (!colorButton || colorButton.dataset.locked !== 'true') {
              firstUnlockedLayer = layer;
              const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
              if (layerCanvas) {
                  const tempImage = new Image();
                  tempImage.src = layerCanvas.toDataURL('image/png');
                  await new Promise(resolve => tempImage.onload = resolve);
                  const colorAnalysis = await analyzer.analyzeImageColors(tempImage);
                  if (colorAnalysis && colorAnalysis.dominantColor) {
                      dominantColor = colorAnalysis.dominantColor;
                      break;
                  }
              }
          }
      }

      if (!dominantColor) {
          console.error('No dominant color found');
          return;
      }

      // Generate harmony colors based on the dominant color
      const harmonyColors = generateHarmonyColors(dominantColor, harmonyType);

      // Process each layer with harmony colors
      for (let layer = 1; layer <= totalLayers; layer++) {
          const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
          if (colorButton && colorButton.dataset.locked === 'true') {
              console.log(`Layer ${layer} is locked, skipping processing`);
              continue;
          }

          const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
          if (!layerCanvas) continue;

          const layerCtx = layerCanvas.getContext('2d');
          if (!layerCtx) continue;

          // Load and analyze the layer
          const originalImg = new Image();
          const originalSrc = layerCanvas.getAttribute('data-original-src');
          if (!originalSrc) continue;

          await new Promise((resolve) => {
              originalImg.onload = () => {
                  layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                  layerCtx.drawImage(originalImg, 0, 0);
                  resolve();
              };
              originalImg.src = originalSrc;
          });

          const tempImage = new Image();
          tempImage.src = layerCanvas.toDataURL('image/png');
          await new Promise(resolve => tempImage.onload = resolve);

          const colorAnalysis = await analyzer.analyzeImageColors(tempImage);
          if (!colorAnalysis) continue;

          // Determine which harmony color to use based on layer position
          const harmonyIndex = (layer - firstUnlockedLayer) % harmonyColors.length;
          const targetColor = harmonyColors[harmonyIndex];

          // Apply the harmony color
          const base64Data = layerCanvas.toDataURL('image/png');
          const colorMapping = await colorProcessor.getColorMapping(base64Data);
          const modifiedImage = await colorProcessor.applyColorMapping(
              base64Data,
              colorMapping,
              targetColor,
              colorAnalysis.dominantColor
          );

          // Update the canvas with the new color
          const img = new Image();
          await new Promise((resolve) => {
              img.onload = () => {
                  layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                  layerCtx.drawImage(img, 0, 0);
                  resolve();
              };
              img.src = modifiedImage;
          });

          updateFooterColorButton(layer, targetColor);
      }
  } catch (error) {
      console.error("Error while processing harmony:", error);
  } finally {
      loadingScreen.style.display = 'none';
  }
}

// Color Conversion Utilities
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
      h = s = 0;
  } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
  }

  return [h, s, l];
}

function hslToRgb(h, s, l) {
  let r, g, b;

  if (s === 0) {
      r = g = b = l;
  } else {
      const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
      };

      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;

      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
  }

  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

// Updated Harmony Generation Functions with variations
function generateMonochromatic(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.2; // Random variation

  return [
      [h, s, l],
      [h, s, Math.min(l + 0.2 + variation, 0.9)],
      [h, s, Math.max(l - 0.2 - variation, 0.1)],
      [h, Math.min(s + 0.15 + variation, 1), l],
      [h, Math.max(s - 0.15 - variation, 0), l]
  ];
}

function generateAnalogous(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.05; // Random angle variation

  return [
      [h, s, l],
      [(h + (1/12 + variation)) % 1, s, l],
      [(h - (1/12 + variation) + 1) % 1, s, Math.min(l + 0.1, 0.9)],
      [(h + (1/6 + variation)) % 1, s, Math.max(l - 0.1, 0.1)],
      [(h - (1/6 + variation) + 1) % 1, Math.min(s + 0.1, 1), l]
  ];
}

function generateComplementary(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.1; // Random variation

  return [
      [h, s, l],
      [(h + 0.5) % 1, s + variation, l],
      [h, Math.min(s + 0.2 + variation, 1), l],
      [h, s, Math.min(l + 0.15 + variation, 0.9)],
      [(h + 0.5) % 1, Math.min(s + 0.15 + variation, 1), Math.min(l + 0.15, 0.9)]
  ];
}

function generateSplitComplementary(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.05; // Random angle variation

  return [
      [h, s, l],
      [(h + 0.5 + (1/12 + variation)) % 1, s, Math.min(l + 0.1, 0.9)],
      [(h + 0.5 - (1/12 + variation) + 1) % 1, s, Math.max(l - 0.1, 0.1)],
      [h, Math.min(s + 0.15 + variation, 1), l],
      [(h + 0.5) % 1, Math.min(s + 0.1, 1), Math.min(l + 0.15, 0.9)]
  ];
}

function generateTriadic(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.05; // Random variation

  return [
      [h, s, l],
      [(h + (1/3 + variation)) % 1, Math.min(s + 0.1, 1), l],
      [(h + (2/3 - variation)) % 1, s, Math.min(l + 0.1, 0.9)],
      [(h + (1/3 + variation)) % 1, Math.max(s - 0.1, 0), Math.max(l - 0.1, 0.1)],
      [(h + (2/3 - variation)) % 1, Math.min(s + 0.15, 1), l]
  ];
}

function generateTetradic(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.05; // Random variation

  return [
      [h, s, l],
      [(h + (0.25 + variation)) % 1, Math.min(s + 0.1, 1), l],
      [(h + (0.5 - variation)) % 1, s, Math.min(l + 0.1, 0.9)],
      [(h + (0.75 + variation)) % 1, Math.max(s - 0.1, 0), Math.max(l - 0.1, 0.1)],
      [h, Math.min(s + 0.15, 1), Math.min(l + 0.15, 0.9)]
  ];
}

function generateSquare(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.05; // Random variation

  return [
      [h, s, l],
      [(h + (0.25 + variation)) % 1, Math.min(s + 0.1, 1), Math.min(l + 0.1, 0.9)],
      [(h + (0.5 - variation)) % 1, Math.max(s - 0.1, 0), l],
      [(h + (0.75 + variation)) % 1, s, Math.max(l - 0.1, 0.1)],
      [h, Math.min(s + 0.2, 1), Math.min(l + 0.15, 0.9)]
  ];
}

// Helper function to add subtle variations to colors
function addVariation(value, amount, min = 0, max = 1) {
  const variation = (Math.random() - 0.5) * 2 * amount;
  return Math.max(min, Math.min(max, value + variation));
}

// Additional function to ensure colors are visually distinct
function ensureDistinctColors(colors) {
  return colors.map((color, index) => {
      if (index === 0) return color; // Keep the base color unchanged
      
      const [h, s, l] = color;
      return [
          addVariation(h, 0.05),
          addVariation(s, 0.1, 0.2, 1),
          addVariation(l, 0.1, 0.2, 0.8)
      ];
  });
}

// Modify the generateHarmonyColors function to use ensureDistinctColors
function generateHarmonyColors(baseColor, harmonyType) {
  const hsl = rgbToHsl(baseColor[0], baseColor[1], baseColor[2]);
  let colors = [];

  switch (harmonyType) {
      case 'Monochromatic':
          colors = generateMonochromatic(hsl);
          break;
      case 'Analogous':
          colors = generateAnalogous(hsl);
          break;
      case 'Complementary':
          colors = generateComplementary(hsl);
          break;
      case 'Split Complementary':
          colors = generateSplitComplementary(hsl);
          break;
      case 'Triadic':
          colors = generateTriadic(hsl);
          break;
      case 'Tetradic':
          colors = generateTetradic(hsl);
          break;
      case 'Square':
          colors = generateSquare(hsl);
          break;
  }

  // Ensure colors are distinct
  colors = ensureDistinctColors(colors);
  
  // Convert back to RGB
  return colors.map(hsl => hslToRgb(hsl[0], hsl[1], hsl[2]));
}
document.addEventListener('DOMContentLoaded', function() {
  const harmonyButton = document.getElementById('harmonyButton');
  const harmonyMenu = document.getElementById('harmonyMenu');
  let selectedHarmony = '';

  // Toggle menu on button click
  harmonyButton.addEventListener('click', function(e) {
      e.stopPropagation();
      harmonyMenu.style.display = harmonyMenu.style.display === 'none' ? 'block' : 'none';
  });

  // Handle menu item selection
  document.querySelectorAll('.menu-item').forEach(item => {
      item.addEventListener('click', function(e) {
          e.stopPropagation();
          selectedHarmony = this.dataset.harmony;
          
          // Remove active class from all items
          document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('active'));
          // Add active class to selected item
          this.classList.add('active');
          
          // Close menu
          harmonyMenu.style.display = 'none';
          
          // Process harmony
          const totalLayers = document.querySelectorAll('[id^="layer_canvas_"]').length;
          const firstCanvas = document.getElementById('layer_canvas_1');
          if (firstCanvas) {
              const ctx = firstCanvas.getContext('2d');
              processHarmony(ctx, totalLayers, firstCanvas, 0, selectedHarmony);
          }
      });
  });

  // Close menu when clicking outside
  document.addEventListener('click', function(e) {
      if (!harmonyButton.contains(e.target) && !harmonyMenu.contains(e.target)) {
          harmonyMenu.style.display = 'none';
      }
  });

  // Prevent menu from closing when clicking inside it
  harmonyMenu.addEventListener('click', function(e) {
      e.stopPropagation();
  });
});
class ImageAdjuster {
  constructor() {
        this.adjustments = {
            combined: {
                hue: 0,
                saturation: 0,
                brightness: 0,
                temperature: 0
            }
        };
        this.showIndividualLayers = false;
        this.setupEventListeners();
        this.originalImageData = {}; // Change to object to store data for each layer
    }

    setupEventListeners() {
        const toggleButton = document.getElementById('adjustmentToggle');
        const adjustmentPanel = document.getElementById('adjustmentPanel');

        toggleButton.addEventListener('click', () => {
            const isHidden = adjustmentPanel.style.display === 'none';
            adjustmentPanel.style.display = isHidden ? 'block' : 'none';
            if (isHidden) {
                this.createAdjustmentSliders();
            }
        });
    }

    createAdjustmentSliders() {
        const container = document.querySelector('.sliders-container');
        container.innerHTML = '';

        // Add toggle button for individual layers
        const toggleLayersBtn = document.createElement('button');
        toggleLayersBtn.textContent = this.showIndividualLayers ? 'Show Combined Layer' : 'Show Individual Layers';
        toggleLayersBtn.className = 'toggle-layers-btn';
        toggleLayersBtn.style.cssText = `
            margin-bottom: 15px;
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        `;
        toggleLayersBtn.addEventListener('click', () => {
            this.showIndividualLayers = !this.showIndividualLayers;
            this.createAdjustmentSliders();
        });
        container.appendChild(toggleLayersBtn);

        if (!this.showIndividualLayers) {
            // Create combined layer controls
            const combinedDiv = document.createElement('div');
            combinedDiv.className = 'layer-adjustments';
            combinedDiv.innerHTML = `
                <h4>All Layers</h4>
                <div class="slider-group">
                    <label>Hue</label>
                    <input type="range" min="-180" max="180" value="${this.adjustments.combined.hue}" 
                           data-layer="combined" data-adjustment="hue">
                </div>
                <div class="slider-group">
                    <label>Saturation</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.saturation}" 
                           data-layer="combined" data-adjustment="saturation">
                </div>
                <div class="slider-group">
                    <label>Brightness</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.brightness}" 
                           data-layer="combined" data-adjustment="brightness">
                </div>
                <div class="slider-group">
                    <label>Temperature</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.temperature}" 
                           data-layer="combined" data-adjustment="temperature">
                </div>
            `;
            container.appendChild(combinedDiv);

            this.setupSliderListeners(combinedDiv);
        } else {
            // Create individual layer controls
            const layerCanvases = document.querySelectorAll('[id^="layer_canvas_"]');
            
            layerCanvases.forEach(layerCanvas => {
                const layer = layerCanvas.id.split('_')[2];
                
                // Initialize layer adjustments if they don't exist
                if (!this.adjustments[layer]) {
                    this.adjustments[layer] = {
                        hue: 0,
                        saturation: 0,
                        brightness: 0,
                        temperature: 0
                    };
                }

                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-adjustments';
                layerDiv.innerHTML = `
                    <h4>Layer ${layer}</h4>
                    <div class="slider-group">
                        <label>Hue</label>
                        <input type="range" min="-180" max="180" value="${this.adjustments[layer].hue}" 
                               data-layer="${layer}" data-adjustment="hue">
                    </div>
                    <div class="slider-group">
                        <label>Saturation</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].saturation}" 
                               data-layer="${layer}" data-adjustment="saturation">
                    </div>
                    <div class="slider-group">
                        <label>Brightness</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].brightness}" 
                               data-layer="${layer}" data-adjustment="brightness">
                    </div>
                    <div class="slider-group">
                        <label>Temperature</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].temperature}" 
                               data-layer="${layer}" data-adjustment="temperature">
                    </div>
                `;

                container.appendChild(layerDiv);
                this.setupSliderListeners(layerDiv);
            });
        }
    }

    setupSliderListeners(containerDiv) {
        containerDiv.querySelectorAll('input[type="range"]').forEach(slider => {
            slider.addEventListener('input', (e) => {
                const layer = e.target.dataset.layer;
                const adjustment = e.target.dataset.adjustment;
                
                // Initialize layer adjustments if they don't exist
                if (!this.adjustments[layer]) {
                    this.adjustments[layer] = {
                        hue: 0,
                        saturation: 0,
                        brightness: 0,
                        temperature: 0
                    };
                }

                this.adjustments[layer][adjustment] = parseInt(e.target.value);
                
                if (layer === 'combined') {
                    // Apply to all layers
                    const layerCanvases = document.querySelectorAll('[id^="layer_canvas_"]');
                    layerCanvases.forEach(canvas => {
                        const layerNum = canvas.id.split('_')[2];
                        // Initialize layer adjustments if they don't exist
                        if (!this.adjustments[layerNum]) {
                            this.adjustments[layerNum] = {
                                hue: 0,
                                saturation: 0,
                                brightness: 0,
                                temperature: 0
                            };
                        }
                        this.adjustments[layerNum][adjustment] = parseInt(e.target.value);
                        this.applyAdjustments(layerNum);
                    });
                } else {
                    this.applyAdjustments(layer);
                }
            });
        });
    }

    applyAdjustments(layer) {
    const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
    if (!layerCanvas) return;

    if (!this.adjustments[layer]) {
        this.adjustments[layer] = {
            hue: 0,
            saturation: 0,
            brightness: 0,
            temperature: 0
        };
    }

    const ctx = layerCanvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, layerCanvas.width, layerCanvas.height);
    const data = imageData.data;

    // Store original image data if not already stored for this layer
    if (!this.originalImageData[layer]) {
        this.originalImageData[layer] = new Uint8ClampedArray(data);
    }

    for (let i = 0; i < data.length; i += 4) {
        // Start from original values for this layer
        let r = this.originalImageData[layer][i];
        let g = this.originalImageData[layer][i + 1];
        let b = this.originalImageData[layer][i + 2];

            // Apply temperature adjustment
            const temp = this.adjustments[layer].temperature;
            if (temp !== 0) {
                const adjustment = temp / 100;
                if (adjustment > 0) {
                    // Warming: increase red, decrease blue
                    r = Math.min(255, r + (adjustment * 30));
                    b = Math.max(0, b - (adjustment * 30));
                } else {
                    // Cooling: decrease red, increase blue
                    r = Math.max(0, r - (Math.abs(adjustment) * 30));
                    b = Math.min(255, b + (Math.abs(adjustment) * 30));
                }
            }

            // Convert to HSL for other adjustments
            let [h, s, l] = this.rgbToHsl(r, g, b);

            // Apply other adjustments
            h = (h + this.adjustments[layer].hue) % 360;
            if (h < 0) h += 360;
            s = Math.max(0, Math.min(100, s + this.adjustments[layer].saturation));
            l = Math.max(0, Math.min(100, l + this.adjustments[layer].brightness));

            // Convert back to RGB
            [r, g, b] = this.hslToRgb(h, s, l);

            // Set final values
            data[i] = Math.round(Math.max(0, Math.min(255, r)));
            data[i + 1] = Math.round(Math.max(0, Math.min(255, g)));
            data[i + 2] = Math.round(Math.max(0, Math.min(255, b)));
            // Alpha channel remains unchanged
        }

        ctx.putImageData(imageData, 0, 0);
    }


    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        return [h * 360, s * 100, l * 100];
    }

    hslToRgb(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;

        let r, g, b;

        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return [r * 255, g * 255, b * 255];
    }
}

// Initialize the adjuster
const imageAdjuster = new ImageAdjuster();


      function showLayerInfoButton(layerIndex){

         $('#colorPickerModal').modal('show');
         updateLayersWithNewColorCount(layerIndex+1);
      }
      function showLayerInfo() {
         contextMenu.style.display = 'none';
         $('#colorPickerModal').modal('show');
         const layerIndex = contextMenu.dataset.layerIndex; // Assuming contextMenu is defined

         updateLayersWithNewColorCount(layerIndex);
       }
      document.addEventListener('DOMContentLoaded', function() {
        const layerColors = {};
        const loadingScreen = document.getElementById('loading-screen');
        const totalLayers = {{ layers|length }};
        let loadedImagesCount = 0;
        const loader = document.getElementById('loading-screen');
        function showContextMenu(event, layerIndex, layerName) {

          event.preventDefault();

          // Set the layer name in the context menu
          layerNameDisplay.innerText = layerName;

          // Get the clicked thumbnail’s coordinates
          const thumbnail = event.target.getBoundingClientRect();
          const toolbarWidth = document.querySelector('.toolbar').offsetWidth;

          // Position the context menu aligned to the toolbar, on the left side of the thumbnail
          contextMenu.style.left = `${thumbnail.left - toolbarWidth - 20}px`; // Adjust as needed
          contextMenu.style.top = `${thumbnail.top + window.scrollY}px`;
          contextMenu.style.display = 'block';
          contextMenu.dataset.layerIndex = layerIndex;

          // Temporarily disable pointer events to avoid immediate hiding
          setTimeout(() => {
            contextMenu.style.pointerEvents = 'auto';
          }, 0);
        }

        // Hide the context menu on clicking outside
        document.addEventListener('click', function(event) {
          if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target) && !event.target.classList.contains('thumbnail')) {
            contextMenu.style.display = 'none';
          }
        });
        function checkIfAllImagesLoaded() {
            if (loadedImagesCount === totalLayers) {
                loadingScreen.style.display = 'none';
                createColorButtons();
            }
        }

      
        function isColorInArray(color, array) {
          return array.some(existingColor =>
              existingColor[0] === color[0] &&
              existingColor[1] === color[1] &&
              existingColor[2] === color[2]
          );
        }
        let distinctColorsArray = [];
        let singleLayerDistinctColorsArray = [];
        let distinctColorsArrayColorPallet = [];

        {% for layer in layers %}
        let img{{ forloop.counter }} = new Image();
        img{{ forloop.counter }}.src = "{{ layer.path }}";
        let canvas{{ forloop.counter }} = document.getElementById('layer_canvas_{{ forloop.counter }}');
        let ctx{{ forloop.counter }} = canvas{{ forloop.counter }}.getContext('2d', { willReadFrequently: true });
        let latestImageData{{ forloop.counter }} = null;
        img{{ forloop.counter }}.onload = function() {
          canvas{{ forloop.counter }}.width = img{{ forloop.counter }}.width;
          canvas{{ forloop.counter }}.height = img{{ forloop.counter }}.height;
          ctx{{ forloop.counter }}.drawImage(img{{ forloop.counter }}, 0, 0);
            layerStates.saveOriginalState({{ forloop.counter }});
            {% comment %} latestImageData{{ forloop.counter }} = ctx{{ forloop.counter }}.getImageData(0, 0, canvas{{ forloop.counter }}.width, canvas{{ forloop.counter }}.height); {% endcomment %}
            const imageData{{ forloop.counter }} = ctx{{ forloop.counter }}.getImageData(0, 0, canvas{{ forloop.counter }}.width, canvas{{ forloop.counter }}.height);

            // Add distinct colors to the set (ensures no duplicates)
            let colorCount =0;
            let distinctColorTolarance =0;

            if(totalLayers>5){
              distinctColorTolarance = 180;
              colorCount=7;

            }else{
              distinctColorTolarance = 190;
              colorCount=7;
            }
            const analysis = analyzeImageLayer(ctx{{ forloop.counter }});
            let { avgLightness, hueTolerance, lightnessTolerance } = analysis;
            hueTolerance = hueTolerance*100;
            if(lightnessTolerance<0.5)lightnessTolerance=0.7
            let distinctColors{{ forloop.counter }} = getDistinctColors(imageData{{ forloop.counter }},distinctColorTolarance, colorCount);

            //console.info(distinctColors{{forloop.counter}});

            distinctColors{{ forloop.counter }}.forEach((color, index) => {

              if (!isColorInArray(color, distinctColorsArray)) {
                if(index == 0){
                  distinctColorsArrayColorPallet.push(color);
                }

                distinctColorsArray.push(color);
              }
            });



            // Create a thumbnail
            const thumbnailCanvas = document.createElement('canvas');
            const thumbnailSize = 30;
            thumbnailCanvas.width = thumbnailSize;
            thumbnailCanvas.height = thumbnailSize;
            const thumbnailCtx = thumbnailCanvas.getContext('2d');
            thumbnailCtx.drawImage(img{{ forloop.counter }}, 0, 0, thumbnailSize, thumbnailSize);
            document.getElementById('thumbnail_{{ forloop.counter }}').src = thumbnailCanvas.toDataURL();

            // Increment the loaded image counter and check if all images are loaded
            loadedImagesCount++;
            checkIfAllImagesLoaded();
          };
          img{{ forloop.counter }}.onerror = function() {
              //console.error(`Failed to load image {{ forloop.counter }}`);
              loadedImagesCount++;
              checkIfAllImagesLoaded();
          };



          let layerName{{ forloop.counter }} = "{{ layer.name }}"; // Store the layer name
          let thumbnail{{ forloop.counter }} = document.getElementById('thumbnail_{{ forloop.counter }}');
          let layerNameElement{{ forloop.counter }} = document.querySelector(`#toggleLayer{{ forloop.counter }}`).nextElementSibling;
          if (thumbnail{{ forloop.counter }}) {
            thumbnail{{ forloop.counter }}.addEventListener('click', function(event) {
              showContextMenu(event, {{ forloop.counter }}, layerName{{ forloop.counter }});
            });
          }

          if (layerNameElement{{ forloop.counter }}) {
            layerNameElement{{ forloop.counter }}.addEventListener('click', function(event) {
              showContextMenu(event, {{ forloop.counter }}, layerName{{ forloop.counter }});
            });
          }
          loader.style.display = 'block';

          setTimeout(() => {
            const buttons = document.querySelectorAll('#image-color-pickers button');
            const rgbColors = generateUniqueRGBColorArray(distinctColorsArrayColorPallet.length+1);
            layerColors[{{ forloop.counter }}] = {
              targetColors: distinctColorsArrayColorPallet,
              newColors: rgbColors
            };
            displayColorPalette({{ forloop.counter }}, rgbColors, distinctColorsArrayColorPallet.length+1);


            const layerIndex = {{ forloop.counter }};
            const layerCanvas = document.getElementById(`layer_canvas_${layerIndex}`);

            const applyButton = document.getElementById(`applyButton_${layerIndex}`);
            const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
            //console.log(layerCtx);

     


            if (applyButton) {
              applyButton.addEventListener('click', async function (event) {
                  // Load the original image first
                  const img = new Image();
                  img.src = "{{ layer.path }}";  // This will be replaced with actual path in the Django template
                  
                  await new Promise((resolve) => {
                      img.onload = resolve;
                  });
          
                  // Reset canvas to original image
                  const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
                  const ctx = canvas.getContext('2d');
                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  ctx.drawImage(img, 0, 0);
          
                  const currentLayerPalette = document.getElementById(`colorPalette_${layerIndex}`);
                  if (!currentLayerPalette) {
                      console.error('Palette not found');
                      return;
                  }
          
                  const trendingPaletteColors = Array.from(currentLayerPalette.querySelectorAll('.color-swatch'))
                      .map(swatch => {
                          const style = window.getComputedStyle(swatch);
                          const color = style.backgroundColor;
                          return color.match(/\d+/g).map(Number);
                      });
          
                  // Process the palette with the original image
                  await processPallet(
                      ctx, 
                      totalLayers, 
                      canvas, 
                      layerIndex, 
                      [], 
                      trendingPaletteColors
                  );
              });
          }
            }, 1000); // 1-second delay
          {% endfor %}
      });
  

      function getDominantColor(imageData) {
    const data = imageData.data;
    const colorCounts = {};
    const allColors = new Map();
    let totalPixels = 0;

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3];

        if (a === 0) continue;
        if ((r === 0 && g === 0 && b === 0) || (r === 255 && g === 255 && b === 255)) continue;

        const [h, s, l] = rgbToHsl(r, g, b);

        if (s < 0.05) continue;

        const colorName = getDominantColorName([r, g, b]);
        const existingColor = allColors.get(colorName);

        if (existingColor) {
            existingColor.pixelCount++;
        } else {
            allColors.set(colorName, { rgb: [r, g, b], colorName, pixelCount: 1 });
        }

        totalPixels++;
    }

    let maxCount = 0;
    let dominantColor = null;

    for (const [colorName, colorInfo] of allColors.entries()) {
        if (colorInfo.pixelCount > maxCount) {
            maxCount = colorInfo.pixelCount;
            dominantColor = colorInfo;
        }
    }

    if (dominantColor) {
        const nonDominantColors = [];
        for (const [colorName, colorInfo] of allColors.entries()) {
            if (colorName !== dominantColor.colorName) {
                const pixelPercentage = (colorInfo.pixelCount / totalPixels) * 100;
                nonDominantColors.push({ ...colorInfo, pixelPercentage });
            }
        }

        return {
            referenceColor: dominantColor.rgb,
            dominantHue: rgbToHsl(...dominantColor.rgb)[0],
            tolerance: {
                hue: 45 / 360,
                saturation: 0.4,
                lightness: 0.45
            },
            isSingleShade: false,
            nonDominantColors,
            dominantColorName: dominantColor.colorName
        };
    }

    return null;
}

// Add this shuffle function at the top level
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function shuffleSinglePalette(layerIndex) {
  const paletteContainer = document.getElementById(`colorPalette_${layerIndex}`);
  if (!paletteContainer) return;

  // Toggle the state for this palette
  window.paletteToggleState[layerIndex] = !window.paletteToggleState[layerIndex];

  if (window.paletteToggleState[layerIndex]) {
      // If toggled on, generate and apply new colors
      const swatches = Array.from(paletteContainer.querySelectorAll('.color-swatch'));
      if (swatches.length === 0) return;

      const colors = swatches.map(swatch => {
          const style = window.getComputedStyle(swatch);
          const bgcolor = style.backgroundColor;
          return bgcolor.match(/\d+/g).map(Number);
      });

      // Shuffle colors
      const shuffledColors = shuffleArray([...colors]);

      // Apply shuffled colors
      swatches.forEach((swatch, index) => {
          swatch.style.backgroundColor = `rgb(${shuffledColors[index].join(',')})`;
      });

      // Store the shuffled colors
      window.trendingPaletteColors = window.trendingPaletteColors || {};
      window.trendingPaletteColors[layerIndex] = shuffledColors;
  } else {
      // If toggled off, revert to original colors
      const originalColors = window.originalPaletteColors[layerIndex];
      if (originalColors) {
          displayColorPalette(layerIndex, originalColors);
      }
  }
}
// Add event listeners for all shuffle buttons
document.addEventListener('DOMContentLoaded', function() {
    const totalLayers = {{ layers|length }};
    
    for (let i = 1; i <= totalLayers; i++) {
        const shuffleButton = document.getElementById(`shufflePalette_${i}`);
        if (shuffleButton) {
            shuffleButton.addEventListener('click', () => shuffleSinglePalette(i));
        }
    }
});




function handleShuffleColors() {
  const imageColorPickerContainer = document.getElementById('image-color-pickers');
  const colorButtons = Array.from(imageColorPickerContainer.getElementsByClassName('pcr-button'));
  
  if (colorButtons.length === 0) return;

  // Filter out locked colors
  const unlockededColors = colorButtons.filter(button => button.dataset.locked !== 'true');
  
  if (unlockededColors.length === 0) {
      console.log('All colors are locked');
      return;
  }
      // Store original colors and their corresponding layers
      const colorData = unlockededColors.map(button => {
        const style = window.getComputedStyle(button);
        const bgcolor = style.backgroundColor;
        const layerIndex = button.dataset.layerIndex;
        const colorArray = bgcolor.match(/\d+/g).map(Number);
        return {
            color: colorArray,
            layerIndex: layerIndex,
            element: button
        };
    });
  const shuffledColors = shuffleArray([...colorData]);
  // Save current states before shuffling
  unlockededColors.forEach(button => {
      const layerIndex = parseInt(button.dataset.layerIndex) + 1;
      layerStates.saveEditedState(layerIndex);
  });
  const originalColors = new Map();
  colorData.forEach(data => {
      originalColors.set(data.layerIndex, data.color);
  });

  // Rest of your existing shuffle code...
  const processPromises = shuffledColors.map((newColorData, index) => {
      const originalData = colorData[index];
      const button = originalData.element;
      const layerIndex = parseInt(originalData.layerIndex) + 1;
      
      button.style.backgroundColor = `rgb(${newColorData.color.join(',')})`;
      
      const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
      if (canvas) {
          if (layerStates.hasEditedState(layerIndex)) {
              return new Promise((resolve) => {
                  const img = new Image();
                  img.onload = async () => {
                      const ctx = canvas.getContext('2d');
                      ctx.clearRect(0, 0, canvas.width, canvas.height);
                      ctx.drawImage(img, 0, 0);
                      
                      await processLayerAsync(ctx, originalColors.get(originalData.layerIndex), newColorData.color);
                      resolve();
                  };
                  img.src = layerStates.getEditedState(layerIndex);
              });
          } else {
              const ctx = canvas.getContext('2d', { willReadFrequently: true });
              return processLayerAsync(ctx, originalColors.get(originalData.layerIndex), newColorData.color);
          }
      }
      return Promise.resolve();
  });
    // Wait for all color processing to complete
    Promise.all(processPromises).then(() => {
        console.log('All layers processed');
        // Update any necessary UI elements or state
    }).catch(error => {
        console.error('Error during color processing:', error);
    });
}

// Add a utility function to check if colors are significantly different
function areColorsDifferent(color1, color2, threshold = 5) {
    return Math.abs(color1[0] - color2[0]) > threshold ||
           Math.abs(color1[1] - color2[1]) > threshold ||
           Math.abs(color1[2] - color2[2]) > threshold;
}

// Modify your createColorButtons function to add layer index to buttons
function createColorButtons() {
    const imageColorAnalyzer = new ImageColorAnalyzer();
    const imageColorPickerContainer = document.getElementById('image-color-pickers');
    imageColorPickerContainer.innerHTML = '';

    const canvasElements = document.querySelectorAll('canvas[id^="layer_canvas_"]');

    canvasElements.forEach((canvas, index) => {
        const layerIndex = index + 1;
        const img = new Image();

        img.onload = () => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);

            imageColorAnalyzer.analyzeImageColors(img)
                .then(colorAnalysis => {
                    if (colorAnalysis) {
                        const dominantColor = colorAnalysis.dominantColor;

                        // Create wrapper div for button and lock
                        const wrapper = document.createElement('div');
                        wrapper.className = 'color-button-wrapper';
                        
                        // Create color button
                        const button = document.createElement('button');
                        button.className = 'pcr-button color-picker';
                        button.style.backgroundColor = `rgb(${dominantColor.join(',')})`;
                        button.dataset.layerIndex = index;
                        button.dataset.locked = 'false';
                        
                        // Create lock overlay
                        const lockOverlay = document.createElement('div');
                        lockOverlay.className = 'lock-overlay';
                        lockOverlay.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                                <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
                            </svg>`;

                        // Add click handler for lock
                        lockOverlay.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const isLocked = button.dataset.locked === 'true';
                            button.dataset.locked = !isLocked;
                            lockOverlay.innerHTML = !isLocked ? 
                                `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-lock" viewBox="0 0 16 16">
                                    <path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2zm3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2zM5 8h6a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1z"/>
                                </svg>` :
                                `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                                    <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
                                </svg>`;
                        });

                        wrapper.appendChild(button);
                        wrapper.appendChild(lockOverlay);
                        imageColorPickerContainer.appendChild(wrapper);
                        
                        button.addEventListener('click', () => {
                            showLayerInfoButton(index);
                        });
                    }
                })
                .catch(error => {
                    console.error(`Error analyzing colors for layer ${layerIndex}:`, error);
                });
        };

        img.src = canvas.toDataURL('image/png');
    });
}
// Add event listener for shuffle button
document.querySelector('.btn-success2').addEventListener('click', handleShuffleColors);

// Add this to your existing DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', function() {
    const layerColors = {};
    const totalLayers = {{ layers|length }};
    let loadedImagesCount = 0;

    function checkIfAllImagesLoaded() {
        if (loadedImagesCount === totalLayers) {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.style.display = 'none';

            // Generate unique RGB color palettes for the trending palettes
            const trendingPalettes = generateUniqueRGBColorPalettes(totalLayers, totalLayers);

            {% for layer in layers %}
            setTimeout(() => {
                const layerIndex = {{ forloop.counter }};
                const layerCanvas = document.getElementById(`layer_canvas_${layerIndex}`);

                if (layerCanvas) {
                    const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });

                    // Display the trending palette colors for this layer
                    const paletteIndex = layerIndex - 1;
                    const paletteColors = trendingPalettes[paletteIndex];
                    displayColorPalette(layerIndex, paletteColors);

                    // Store the colors for this layer
                    layerColors[layerIndex] = {
                        targetColors: paletteColors,
                        newColors: paletteColors
                    };
                }
            }, 1000); // 1-second delay
            {% endfor %}
        }
    }

    {% for layer in layers %}
    let img{{ forloop.counter }} = new Image();
    img{{ forloop.counter }}.src = "{{ layer.path }}";
    let canvas{{ forloop.counter }} = document.getElementById('layer_canvas_{{ forloop.counter }}');
    let ctx{{ forloop.counter }} = canvas{{ forloop.counter }}.getContext('2d', { willReadFrequently: true });
    img{{ forloop.counter }}.onload = function() {
        canvas{{ forloop.counter }}.width = img{{ forloop.counter }}.width;
        canvas{{ forloop.counter }}.height = img{{ forloop.counter }}.height;
        ctx{{ forloop.counter }}.drawImage(img{{ forloop.counter }}, 0, 0);
        loadedImagesCount++;
        checkIfAllImagesLoaded();
    };
    img{{ forloop.counter }}.onerror = function() {
        loadedImagesCount++;
        checkIfAllImagesLoaded();
    };
    {% endfor %}
});

function generateUniqueRGBColorPalettes(count, totalLayers) {
    const palettes = [];

    for (let i = 0; i < count; i++) {
        const colors = generateUniqueRGBColorArray(totalLayers);
        palettes.push(colors);
    }

    return palettes;
}

    </script>
  </body>
</html>
